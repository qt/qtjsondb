/****************************************************************************
**
** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/
**
** This file is part of the QtAddOn.JsonDb module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** GNU Lesser General Public License Usage
** This file may be used under the terms of the GNU Lesser General Public
** License version 2.1 as published by the Free Software Foundation and
** appearing in the file LICENSE.LGPL included in the packaging of this
** file. Please review the following information to ensure the GNU Lesser
** General Public License version 2.1 requirements will be met:
** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain additional
** rights. These rights are described in the Nokia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU General
** Public License version 3.0 as published by the Free Software Foundation
** and appearing in the file LICENSE.GPL included in the packaging of this
** file. Please review the following information to ensure the GNU General
** Public License version 3.0 requirements will be met:
** http://www.gnu.org/copyleft/gpl.html.
**
** Other Usage
** Alternatively, this file may be used in accordance with the terms and
** conditions contained in a signed written agreement between you and Nokia.
**
**
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include <QCoreApplication>
#include <QtTest/QtTest>
#include <QByteArray>
#include <QFile>
#include <QFileInfo>
#include <QDir>
#include <QTime>


#include "hbtree.h"
#include "hbtreetransaction.h"
#include "hbtreecursor.h"
#include "hbtree_p.h"
#include "orderedlist_p.h"

const int numTable[] = {
    848189692, 10993076, 645053843, 409500027, 984193993, 476551019, 863168763,
    189550775, 620531785, 882318228, 974619333, 104980108, 429916131, 425358349,
    976756622, 213935863, 525889081, 497194771, 547376784, 99654879, 187833234,
    402439589, 384382490, 811793844, 7578594, 684311150, 637826917, 548853608,
    604605157, 693394199, 471165060, 55892137, 366297952, 406539972, 184563094,
    512949392, 630770033, 700001349, 759041842, 708022925, 594331986, 698051284,
    955691480, 585571851, 420409045, 994546042, 233741568, 680619539, 705709863,
    657350725, 342950391, 993226155, 606955683, 199109651, 118229552, 767341883,
    599199179, 264470497, 485401663, 498326809, 453743092, 751407343, 677537279,
    310808105, 564242575, 673855596, 488033226, 363010456, 808859556, 667060342,
    710043839, 988919034, 705003802, 785502484, 49227525, 944187253, 544603447,
    854894925, 171358730, 703649323, 31805418, 779781548, 96264569, 128819404,
    237708414, 259006804, 751867891, 396079091, 15402002, 728853858, 315314340,
    420740047, 332950395, 403056770, 433085426, 379441409, 713018405, 229104170,
    444346824, 568466597, 126679873, 603401927, 192337906, 142869063, 298813060,
    312938494, 767679766, 877273319, 894146161, 234870475, 989792174, 928079529,
    907472137, 298886155, 654935201, 961510055, 776834239, 314388067, 867922864,
    661879818, 258586058, 798595442, 80232854, 366181709, 84140005, 701004045,
    961029950, 252150466, 100741184, 261625126, 139626244, 200147915, 266749557,
    959292560, 30416318, 375699593, 194326122, 720297908, 937907539, 60132521,
    829442640, 9311807, 955613853, 875326657, 990691860, 793906406, 352711045,
    722873563, 771474630, 965879673, 347634359, 891881084, 247410893, 618862072,
    684825656, 146801761, 356466670, 340306238, 517000394, 252843641, 849570371,
    889308949, 754491839, 269987401, 440344953, 24213230, 880531633, 351587626,
    384666871, 374269354, 184114700, 509725713, 859903249, 458033424, 963253048,
    264317543, 628748271, 725233377, 924451102, 174289392, 279516086, 151788945,
    281948121, 414942694, 721490429, 580817193, 172552112, 481249451, 686184161,
    685929365, 370683408, 211909844, 152566235, 970197058, 330764665, 548119630,
    634516417, 805315428, 748727908, 54911679, 688815383, 548986840, 492389719,
    407926225, 888441383, 37948285, 800971340, 529988987, 450792776, 957385996,
    42868423, 960136153, 56313419, 762565383, 31218182, 879321747, 767085557,
    866201897, 712623721, 415100828, 279717137, 927750341, 338595090, 290039427,
    424474437, 186963334, 821180607, 271128275, 834250250, 950393570, 455335374,
    452447855, 2268761, 293475929, 775715882, 900166271, 650995288, 166052363,
    158076812, 380387909, 440737214, 802884059, 83349567, 583235617, 83480203,
    92259078, 254630666, 149735337, 566843053, 548344387, 319145994, 135426562,
    402577989, 605326638, 897244523, 925015126, 818337018, 66205440, 596757586,
    566733131, 396716443, 239460074, 637159132, 776952070, 37809166, 651891990,
    920272817, 365134750, 994845964, 285395632, 418600430, 815274973, 280399865,
    981257320, 579278145, 24277230, 854931043, 960099072, 409759114, 925069893,
    793286907, 201383845, 363560741, 646428670, 431751918, 607148622, 330707665,
    6889901, 507962997, 955047061, 3872640, 464138748, 570569438, 159583308,
    655698825, 598099323, 342946875, 791833026, 920102872, 309249273, 284403302,
    305399765, 875033418, 107517235, 253026819, 570808937, 960985628, 126952081,
    659223731, 832791579, 484311215, 488932142, 695418166, 199030904, 606713606,
    34123894, 253491490, 518691960, 187922922, 191424529, 468492581, 701313038,
    855619776, 83491515, 871119223, 981078464, 52438872, 398732319, 858061094,
    467240512, 858291662, 898043910, 665369364, 46756668, 534658550, 675831861,
    11319654, 841868447, 568395369, 408702164, 47871623, 8682009, 340447733,
    396117084, 544335074, 317572646, 563577638, 375667353, 581661575, 480335903,
    709180193, 702706004, 748467159, 264357583, 490616703, 967509412, 794311362,
    824390771, 539501107, 460290916, 203637139, 823678917, 269663424, 251185635,
    528435930, 250592470, 125007712, 162373828, 249638242, 897552841, 111153041,
    68546307, 16539853, 500203402, 514691800, 846711082, 476724522, 751648880,
    284907429, 223750891, 461824660, 22203496, 927714219, 103375328, 226679129,
    343801675, 410683741, 662876127, 642448624, 823652673, 744977517, 211254601,
    584346613, 223930236, 32320073, 852680664, 76195914, 637601727, 213067171,
    988234955, 421185336, 701090298, 184315378, 980162409, 882204808, 844177121,
    311549108, 672901229, 959120164, 814352371, 488384190, 927146614, 349703662,
    186343082, 854370157, 413250201, 505366773, 544195813, 571021732, 777321977,
    957918168, 437745398, 420848013, 758686825, 49230567, 952504063, 754528208,
    216282559, 39857047, 781643644, 517287902, 685144252, 53080328, 176501393,
    314133495, 94925012, 335514732, 622579867, 995931074, 205455659, 471137539,
    35879971, 806434913, 351097670, 797539312, 71090457, 39537896, 821216869,
    486203004, 739486333, 665910334, 998578817, 592034178, 234007511, 751753090,
    690008266, 763272076, 739769513, 458149169, 182852976, 795820155, 836303169,
    215774322, 290893763, 872796270, 553311644, 665943068, 389904453, 227113503,
    707271622, 704147607, 556558137, 453411381, 402243056, 747971677, 25132021,
    259074289, 304137083, 15339150, 110072525, 406982613, 499090112, 633525368,
    584481924, 464446717, 809848581, 737796882, 687155562, 683067810, 937787005,
    88587820, 744584471, 892943475, 112354794, 742100799, 77811196, 359942796,
    914528488, 991917379, 485475166, 61501009, 784742991, 977027678, 528495297,
    37093846, 424260715, 3077573, 891591705, 149788204, 163802560, 940326182,
    917027406, 758531089, 523616933, 272806097, 453509326, 305286991, 349581973,
    473504448, 5560079, 521199419, 501606455, 158475366, 7212964, 332592858,
    956497579, 12147025, 151572294, 936232257, 700523088, 67641443, 255216575,
    957338069, 466302788, 17176501, 796861794, 52092358, 162305986, 543977652,
    629453068, 149014528, 313091161, 331409756, 981260170, 644985912, 432037934,
    289978047, 59326622, 990432018, 723854748, 57806143, 713844239, 727454720,
    59216592, 128423746, 769145870, 691067843, 469500605, 837208188, 885565310,
    514060889, 644608075, 239597267, 915775593, 477528142, 562133357, 584141571,
    522531248, 781432566, 344694067, 360376036, 83128405, 685968901, 378932316,
    32983033, 818808827, 158797173, 110515426, 480883524, 200089514, 435058797,
    249047811, 509532459, 593668380, 73162423, 641066590, 224847703, 804970820,
    773169536, 526570395, 696885897, 351507760, 590315591, 116628037, 185705275,
    37173725, 952553184, 828569604, 352534506, 226567046, 684091785, 429908045,
    62483386, 423884994, 16731919, 823610829, 836422487, 502539519, 826804069,
    607751967, 730822006, 31495231, 360238715, 117927452, 929334063, 468020707,
    174183689, 361334631, 126474083, 639685359, 420659341, 530064354, 285854325,
    297243996, 872140054, 572715727, 342676829, 461407627, 849608906, 305377445,
    775409327, 24282212, 269400090, 771197476, 166096849, 106649848, 62657287,
    468403216, 569333832, 945643519, 378862904, 918394671, 497621649, 533673155,
    572578160, 769500975, 792482952, 863789829, 381078176, 437248601, 213373020,
    940954563, 436915022, 811081090, 329897793, 150976601, 15467602, 157885653,
    558722987, 269877547, 342406631, 20021897, 647129232, 450809663, 861148518,
    488908804, 218219500, 278679247, 313653170, 622136074, 971438780, 462015354,
    504026377, 764685584, 272547928, 826841938, 918290616, 330714146, 673902818,
    399122744, 508577045, 665934474, 467732722, 148808232, 656791746, 458935623,
    21754679, 845201292, 477465776, 138208306, 115518317, 405161876, 778370430,
    850276840, 863041752, 760478013, 851373892, 399458751, 726273151, 554923760,
    417151454, 780092102, 452549778, 644917700, 196446359, 670212793, 758050005,
    528132198, 147369870, 632952508, 931290299, 663487394, 35802445, 533359640,
    36474735, 266634115, 372865288, 388616170, 237924630, 859740792, 254473611,
    379674197, 819824423, 605862996, 620050878, 982746908, 778460581, 534480456,
    471899100, 958618990, 118209331, 348828553, 243279104, 158424021, 856761075,
    717398822, 699213476, 209043615, 265305256, 742183408, 118135106, 888465493,
    713548914, 355543765, 146508489, 857793812, 157618072, 181894366, 804811373,
    593764653, 116864074, 23545411, 337250012, 488242490, 469406446, 746701545,
    962576158, 498644838, 984714657, 382396589, 426167476, 375408350, 713482345,
    972444496, 89171094, 927192738, 523220523, 497267633, 650116356, 284404977,
    424865721, 258658451, 794175061, 998784444, 435620018, 116514174, 677450576,
    603377874, 981854455, 571410872, 335304876, 816544571, 726554722, 960511256,
    47115975, 664063310, 140471531, 162877064, 114055896, 302796645, 26380455,
    242792808, 405271209, 234885723, 136798580, 466219581, 919056559, 378981007,
    789952739, 312907104, 267337882, 981945772, 539519993, 343554385, 376981664,
    555033242, 382998660, 561425674, 603045848, 12398668, 248836544, 655427824,
    705587501, 38644786, 739444274, 803395265, 772330109, 712936177, 643202045,
    136434788, 998396580, 604883428, 964125027, 433386345, 881730, 434181005,
    476054565, 718311716, 902720665, 648500333, 531129058, 997252246, 369989220,
    556804958, 550327220, 40438597, 499450960, 452788830, 898219995, 134795998,
    318438471, 145085601, 663972766, 332674123, 757001054, 171665328, 682390427,
    246728842, 480453831, 278114873, 827345972, 377299509, 998532743, 999418668,
    30490662, 557560279, 743218198, 555490849, 453130291, 652941728, 303364130,
    464030313, 944550574, 595763647, 479262222, 536148795, 598679364, 628206935,
    520179478, 966133137, 218604753, 644394765, 994869861, 838676770, 17329692,
    725230441, 589765146, 717354461, 602691663, 327720891, 781897376, 238928647,
    499827203, 293834046, 194552486, 991506193, 653295430, 778418128, 507138133,
    73120666, 86597533, 284783460, 977698073, 223457231, 960823753, 416321149,
    498814784, 778367569, 532495354, 137376757, 183824249, 976172498, 423089751,
    499345663, 318699784, 968797837, 977712444, 359362416, 330320199, 246796656,
    504811649, 634153846, 166373490, 561183852, 801832263, 824809308, 666734797,
    814289976, 505818804, 444015079, 510605735, 153259785, 852302914, 229929797,
    726865908, 413005812, 656778627, 232589072, 531458551, 735186365, 550131726,
    764497270, 526049515, 862494069, 225436408, 735622734, 73129791, 208801747,
    500981533, 2691762, 624198809, 613882899, 878335742, 37732456, 798223917,
    959860869, 110240166, 694900164, 200793474, 131099778, 363368406, 894173418,
    232050461, 155816864, 689849455, 30942176, 925775497, 21445699, 156633173,
    729053788, 826170454, 784151325, 923828866, 730062913, 946997455, 556465218,
    56181315, 755936148, 547449937, 285535941, 463528391, 119906422, 100106284,
    2392218, 486428299, 207538903, 871655184, 106247345, 597192390, 94328438,
    980442297, 423384099, 279949842, 355089861, 773864453, 796275381, 569971729,
    455641094, 274775875, 381612740, 211745150, 309070229, 102550478, 20376042,
    44664531, 343320066, 392010532, 560580109, 147453160, 49249495, 607385181,
    993874606, 108588345, 817958430, 339543900, 323097667, 721185174, 310316459,
    443892528, 415618019, 668179436, 368129193, 205357036, 606822555, 306213312,
    522092059, 443550543, 246411272, 306381129, 506600039, 200867001, 418629929,
    900629291, 866962414, 546447654, 710866456, 307411480, 583652469, 527667546,
    356890495, 164934603, 698490795, 928099098, 196060225, 129317941, 603678952,
    31059585, 476892387, 573722090, 695949837, 504755959, 736464356, 262485906,
    791007118, 514091286, 203493932, 664860930, 240121590, 918990458, 377203497,
    643436935, 961687339, 814922061, 614710057, 340711403, 953091120, 481024954,
    850327934, 518828409, 713988453, 680184501, 345490101, 38742242, 538813883,
    166368675, 901349979, 701887624, 948317567, 761723703, 138892757, 512379698,
    470905815, 560757725, 895476090, 668801641, 47849918, 993470232, 896611375,
    749799275, 371997875, 83316245, 101722019, 398909482, 957480149, 26485002,
    804284974, 487626355, 140097867, 538840460, 541157031, 839013233, 488917032,
    297780982, 493422196, 854714730, 75156410, 852815167, 686005154, 146384515,
    339794421, 656141675, 789840704, 949051699, 254917022, 372611454, 281728735,
    837453021, 698415532, 816269694, 375308130, 67252244, 946710858, 348149848,
    538195502, 190713347, 283628118, 306213577, 774245373, 926851282, 361947118,
    132256795, 111308598, 959234460, 621517675, 181890138, 220892023, 311879337,
    905640572, 347000601, 804864245, 95895708, 454699094, 285571948, 898000404,
    989944554, 57450212, 321715089, 640108564, 60890407, 490484731, 199691888,
    120103868, 466549058, 774226956, 107173183, 975097603, 318490029, 593253917,
    192424886, 249835295, 739812834, 558773876, 451449633, 866718943, 337880326,
    868514356, 810292323, 654529722, 737958639, 843998714, 123815634, 836479523,
    395272160, 394565840, 664735602, 919815318, 862632708, 697277096, 84065121,
    851082587, 217126227, 632650025, 945915428, 896623165, 245248194, 255290442,
    342966757, 642696891, 410538967, 227978506, 65407594, 249058213, 733026750,
    979813907, 664315765, 946077922, 167785550, 314552969, 797700658, 101217926,
    19942470, 974487589, 778819713, 638155196, 864222796, 398603484, 956522298,
    396623901, 54934936, 674641337, 393053496, 118050597, 355649516, 855903796,
    198049823, 546535041, 884536142, 586126496, 80228417, 31378260, 52922876,
    3224227, 481222144, 538599118, 255862019, 159746047, 205376118, 36874989,
    355281787, 658567690, 342698503, 354047617, 180772043, 233362277, 89432084,
    729625078, 276239734, 652350314, 45009425, 323014482, 127141327, 232232486,
    396381253, 685078081, 80318105, 701342910, 965195265, 195415968, 379721785,
    929530701, 613609193, 312419928, 409372464, 850595844, 580161966, 313302195,
    410780299, 876594572, 141976512, 386730118, 367903460, 985883632, 956902372,
    568880342, 301258591, 576472738, 623951430, 441339969, 946671902, 767324746,
    325211896, 693304816, 103404695, 575793805, 610876045, 127015316, 834970965,
    63790493, 280209060, 360452502, 266751397, 724376012, 23175408, 426832106,
    248548059, 107801908, 161269854, 15120476, 222522956, 280638680, 134591682,
    923507462, 633197272, 177468320, 207865171, 380112812, 272450375, 454073436,
    644984676, 102509240, 593814966, 809827877, 980599388, 645422179, 618875494,
    529388237, 300241626, 124898690, 281183689, 242468733, 533897794, 19521060,
    652110877, 510365289, 811183304, 478072578, 562812519, 10925485, 199299301,
    384522681, 142022033, 701925158, 24469358, 307955776, 519568801, 993594939,
    637499018, 200866035, 616289898, 782974385, 627391223, 335655069, 85321833,
    685719499, 949437811, 605840186, 207042882, 903822304, 678440159, 928923956,
    451340208, 83738688, 478540419, 915630701, 71638847, 469264787, 170062583,
    720929819, 254784640, 285240438, 136936973, 669868642, 687375877, 78056417,
    609759192, 687060468, 877273733, 245731327, 715093205, 519846225, 425152230,
    985468881, 368494270, 648635930, 958755216, 549458681, 567600568, 994148963,
    977150656, 979704599, 603621700, 147746176, 831460158, 831990900, 799796051,
    193695072, 242439605, 111711618, 657524879, 600168094, 469134244, 583489915,
    323352503, 702327839, 295975552, 658507248, 533345130, 837509250, 14183394,
    2635127, 296247937, 464513703, 944126245, 897010829, 641528016, 524570059,
    549427583, 728294283, 64862106, 486994085, 995193903, 370436200, 199803498,
    649816264, 397590129, 167759507, 88568724, 22552000, 912233699, 961358943,
    348470327, 38493448, 283233719, 973078021, 383853713, 857932684, 241783772,
    257154878, 368999511, 18783004, 729638385, 41828331, 782245470, 949806205,
    777164733, 974753717, 167284241, 308002201, 3267471, 843851234, 705625015,
    988273529, 620860862, 209420507, 810106933, 111764064, 648003308, 830280002,
    603378858, 733271264, 608779787, 956947909, 595825676, 656681289, 483044481,
    4235163, 623748761, 248837590, 78916140, 136796084, 389745830, 856059020,
    924239590, 228004358, 545664786, 177785250, 943709360, 33331945, 259900438,
    234264371, 752892123, 722374879, 190136766, 782433578, 634274413, 797881833,
    237894743, 152061973, 561781936, 291864669, 411115355, 745207462, 954884504,
    655072374, 671630377, 774471330, 440449403, 246848676, 288618061, 558446377,
    430556287, 255856467, 393553722, 845756175, 170925300, 225836743, 224182674,
    103640463, 131792642, 132416082, 247947221, 697043579, 969572463, 959587746,
    814100656, 27395427, 717808644, 103755627, 372247499, 859143675, 789236076,
    15047224, 132780623, 419021722, 550116697, 660625639, 9551777, 560369193,
    920509699, 261457731, 168917223, 776819292, 332731128, 669552584, 483840923,
    135528480, 856103976, 25056835, 124387139, 779456990, 845773872, 354034764,
    64048972, 756624467, 75119673, 219059682, 34862893, 737200869, 198709234,
    731912032, 163715850, 748634068, 765956860, 583763405, 436124700, 918451500,
    525811899, 996739298, 698371868, 959555369, 80237102, 228217827, 642232678,
    37736388, 774834617, 851749039, 812241885, 205832499, 637495146, 77053930,
    237258110, 4907451, 666183950, 578555948, 827588736, 79484987, 988947201,
    182410476, 835444274, 132923819, 724878925, 535063085, 611519084, 937728464,
    454590322, 227557380, 759200183, 745322591, 463223527, 316828208, 21186788,
    332927171, 934278043, 531259529, 438769119, 175155037, 716607568, 978499863,
    147231185, 121030615, 661496108, 124169636, 906597444, 218175855, 590021153,
    105901186, 714355483, 698002107, 683130253, 563338684, 304160987, 291286852,
    53680383, 215413738, 977601503, 233263220, 818575498, 435440132, 57352040,
    553789666, 789654242, 325850699, 443320569, 639047109, 283678298, 258328672,
    714311935, 631816360, 262858416, 366466950, 678620519, 904667174, 288879153,
    873303158, 251348095, 11378432, 950776725, 648173194, 223067922, 455020911,
    510683659, 574662386, 258648735, 205135864, 63969626, 601769967, 3771023,
    383651516, 326381819, 681214592, 939744357, 157416121, 808064227, 364166404,
    87364270, 6108191, 945227777, 860232557, 96046641, 960643911, 698349369,
    547510642, 255457258, 30905115, 313866308, 519451040, 648017527, 478028309,
    332113567, 6472796, 404120079, 455441490, 7582979, 573495351, 955830057,
    106881088, 99175095, 548648485, 353192352, 984153829, 306244013, 941400681,
    749807405, 312151901, 361370913, 486427872, 317146907, 795562830, 642459212,
    132290970, 746596418, 610525343, 350959539, 41590650, 484538114, 884627348,
    134891748, 806473861, 23929837, 238411366, 848158727, 430777732, 316089667,
    478291373, 331732676, 382330253, 487607674, 841167349, 646056736, 501868681,
    233417469, 654677828, 886372683, 979464430, 893622553, 865165513, 784587409,
    31338344, 163970458, 416756909, 948321817, 15474199, 437979001, 430473634,
    274210217, 514599955, 552908136, 774344620, 5808174, 500545912, 800636184,
    325828234, 399417502, 955917014, 42982149, 897970903, 105217442, 757944586,
    579029777, 769865706, 328486564, 617464824, 240187474, 197899283, 907080748,
    134713225, 805335451, 995274647, 241861824, 709793489, 402852114, 328026051,
    430939182, 944521597, 463869698, 542764466, 223028549, 893712695, 791613141,
    41337876, 302069038, 597946650, 521604492, 216588220, 244280072, 11826377,
    775023680, 184913323, 169539030, 846053778, 775205011, 203729403, 784112512,
    359809454, 540868690, 809917444, 321965167, 200798786, 960463645, 750933904,
    838132497, 234925892, 391249204, 689845094, 288856095, 263749308, 74556213,
    459845104, 20286321, 728832122, 542849994, 564917894, 383945964, 933502793,
    960354373, 251670570, 604142787, 446526857, 837838090, 390874276, 406102010,
    648004559, 418224175, 961958165, 271199372, 538011872, 956107836, 918806872,
    79721985, 192771765, 404072914, 92681232, 134524473, 213326341, 376310476,
    925713561, 219184141, 695248347, 158529634, 220225039, 718349294, 94377974,
    964499351, 398987817, 674841302, 813089483, 205060046, 790220829, 988289167,
    117135511, 224375951, 888469629, 709287183, 505545415, 461569350, 448250227,
    145676753, 591211879, 395016852, 731158947, 76174544, 852094079, 205579766,
    97605392, 286225065, 800992602, 771197108, 588778684, 557298858, 486139073,
    842422902, 125048708, 17403374, 971126302, 925344098, 880404134, 845631636,
    676481084, 731994190, 2770692, 317130060, 147410383, 277938177, 224471844,
    30972463, 543053815, 865381106, 780207615, 275507741, 787098750, 183970013,
    956651360, 799227471, 697049439, 714720712, 205915244, 357696582, 355212344,
    897086524, 596465009, 661669996, 792046421, 663256238, 807009079, 214624544,
    488796606, 613327777, 220196128, 804548592, 300398258, 939796306, 305474753,
    578652970, 675734947, 837243384, 137997587, 125229387, 569229847, 480616643,
    802042774, 448295673, 880484133, 573980282, 980656895, 591768106, 353502870,
    796651159, 45612776, 655732185, 69459782, 21554207, 706739903, 625803497,
    773238566, 108667900, 508062300, 681795239, 703612581, 813986762, 579264568,
    238336432, 40672437, 215804312, 139315814, 410260376, 327243644, 209994985,
    67614047, 984069223, 340792170, 797210884, 886146806, 107870042, 993818258,
    266768614, 93518387, 985210478, 155899343, 983688056, 735233991, 64281666,
    272348955, 179123159, 91412859, 823208316, 413099220, 876357937, 342016574,
    212875255, 804759144, 432465082, 168054490, 572411507, 884545034, 387970152,
    184556039, 707654209, 482279913, 60146511, 919870099, 210297603, 107821830,
    353574621, 29536045, 37597934, 159252231, 154572321, 26347945, 644339842,
    32820485, 640008829, 190545208, 745691485, 856872706, 496695702, 791045972,
    90498636, 530043170, 25704026, 215717054, 575607906, 451518802, 83973516,
    984551517, 175652254, 374006459, 267515845, 119457812, 16987343, 626881918,
    321376375, 939398835, 626465021, 303376171, 980117704, 665869956, 314662285,
    208746318, 735857963, 545041877, 65287692, 911251297, 422148683, 255168033,
    477622068, 29921362, 18761477, 539717793, 37655340, 138354201, 189978265,
    216080423, 249747050, 879761496, 34016871, 9213097, 185543986, 57506779,
    687411991, 748288962, 86176192, 179074207, 607297998, 585588117, 386740373,
    628845985, 182116643, 221390247, 218188790, 778034266, 563605897, 585565495,
    784088282, 971547904, 367393983, 594811977, 850054433, 360767622, 677781288,
    318122171, 159134443, 356170971, 918140320, 907243664, 67867730, 413122244,
    627449502, 212880994, 583168910, 32573738, 721558426, 629947042, 914148179,
    98248125, 708859304, 942666487, 181376643, 303335658, 304783887, 931422163,
    945836424, 44304077, 511380957, 402800403, 759276338, 704421213, 34000887,
    449915297, 423185890, 81514564, 239680295, 113510258, 682250905, 822618226,
    225517576, 87839229, 949548351, 895508748, 159603856, 6559669, 977981000,
    15518103, 148376135, 128925488, 198883970, 926981363, 707595450, 978693631,
    696063237, 147472471, 195118610, 335158236, 766663657, 536122291, 633691742,
    483585912, 19289048, 6405705, 220748045, 41743720, 330324729, 591149162,
    630879371, 330725638, 550692921, 669452715, 100901213, 869976756, 284248631,
    289426815, 625271913, 67650962, 341307503, 355432180, 959832408, 176297161,
    717359977, 383944962, 213557699, 486995177, 357498301, 710897713, 963260577,
    713861423, 916107106, 946787087, 62707837, 44112884, 827067015, 983391468,
    229539947, 164484743, 123725607, 75681956, 90497629, 488075628, 806667940,
    641709105, 107682677, 868425460, 11225837, 617649030, 734519736, 431248727,
    584959200, 763012951, 464813794, 883093484, 867042737, 498551559, 122316416,
    632451753, 414910084, 475813015, 987772726, 967064310, 71014502, 281385144,
    923198368, 983682060, 843102198, 86610560, 46539652, 474976670, 958728108,
    664051292, 770147308, 34417311, 442030758, 741647443, 18013215, 496828044,
    205810390, 196382183, 120650767, 113030313, 213739940, 38091751, 505555988,
    42477633, 781721043, 384957646, 563883261, 980881564, 788816115, 603480985,
    117956927, 375907834, 600918635, 179727498, 341242394, 360743875, 236884723,
    71319470, 59730697, 662046974, 102237103, 405120945, 366993763, 695332067,
    511646874, 6207494, 302072190, 374050189, 774800524, 452017426, 699896545,
    950428756, 216830696, 151751955, 53214476, 522289746, 711481262, 787152244,
    400919952, 873510344, 959250934, 982166823, 975400213, 73228540, 489634631,
    917355659, 823841526, 831431238, 435674087, 228511574, 955174383, 776270994,
    182840938, 849082, 422316481, 974883875, 973915029, 560529806, 37173005,
    967129286, 1274100, 782899114, 36594607, 8247309, 349372800, 583699805,
    871329430, 847981353, 570527879, 205812242, 164059594, 662369829, 135386656,
    838287193, 109597288, 101433862, 223752959, 77887725, 258855697, 424358529,
    75276005, 1064425, 931632683, 833004874, 832850426, 540340436, 271529541,
    386796897, 378082957, 874675387, 630525756, 728304638, 408912528, 268422989,
    692591124, 408732873, 409106959, 953919237, 293279118, 132549181, 702815918,
    311959291, 414035878, 394190568, 801885949, 141053404, 334976355, 464988056,
    814383924, 878215942, 840826119, 583033225, 55647378, 97887178, 736703528,
    678397984, 556320014, 19325273, 135620923, 674288813, 114358646, 570774401,
    609475778, 339327726, 831955560, 102983925, 128045535, 86840194, 6669853,
    659410791, 670856618, 106864281, 986742303, 969969045, 743567159, 38595145,
    314131783, 722249582, 616412836, 387032008, 619462905, 861203612, 143521239,
    283441551, 841024280, 393328687, 348922334, 10212838, 995703752, 364981125,
    709137133, 4687919, 634912254, 317262215, 890368979, 864316425, 456396211,
    156439241, 864836060, 97515822, 933774450, 616673310, 436550670, 792975539,
    288481624, 552515628, 789933887, 779754197, 178683812, 324621662, 849032968,
    869638171, 840301533, 246663103, 916596402, 903640972, 316633488, 928176149,
    911263757, 777994570, 309314769, 823073344, 599259966, 21419777, 742758941,
    720144877, 249789807, 259610068, 584115689, 65715411, 191672692, 779030966,
    821068210, 619707564, 715002628, 512390944, 256097887, 749826926, 211200135,
    947578613, 965083464, 150226325, 177536892, 278203930, 750077619, 878982305,
    421607864, 792300277, 216695394, 660023582, 182718390, 445841099, 260777687,
    487346529, 429325603, 258109757, 440938786, 566104794, 2143322, 289036281,
    79310537, 71233077, 964452631, 806980148, 113323163, 359334314, 919127585,
    487924091, 570869634, 759107993, 520959361, 458613430, 757361101, 989867042,
    422118512, 719258553, 886516584, 51601064, 565426099, 727741666, 921298687,
    510470629, 779397882, 240276091, 30606931, 320266346, 226090452, 939538508,
    577717128, 466083203, 532247908, 568738198, 857527418, 891486670, 43254489,
    109990618, 591382621, 307675108, 364667419, 652314378, 414795588, 710406053,
    376134233, 277101120, 179601403, 760109096, 474359422, 649640829, 23349646,
    890603178, 757513119, 623170438, 163483145, 240929748, 194766383, 405882650,
    244439726, 513621033, 247005208, 203335333, 121317370, 766384319, 465213179,
    47597682, 385767793, 905459967, 909660901, 694127775, 261570522, 307628414,
    24884053, 357745713, 516837300, 341603078, 225550036, 467356299, 272008945,
    376057152, 438468187, 301755152, 88499788, 803580347, 718744913, 922972239,
    287948847, 817742724, 930366877, 130963253, 726250692, 228297011, 322351301,
    509155588, 229806187, 978991559, 834023898, 398088713, 3887634, 821256295,
    28165065, 476606846, 199222538, 303385198, 271989641, 702797295, 913804358,
    322143716, 858756962, 294640258, 857193874, 933147171, 131850812, 86042405,
    357677221, 294365702, 771415653, 742719096, 66361218, 624129669, 39503099,
    787387510, 655794961, 896117221, 276015621, 600505261, 820658152, 709575697,
    904892943, 954236769, 975006413, 516392624, 407542918, 786209990, 59492998,
    217285479, 653709585, 275978271, 447734943, 490198007, 55698465, 725167872,
    659406108, 451708430, 332916485, 315691238, 827349446, 863012677, 349178172,
    552977053, 167752466, 855389475, 630044376, 81917168, 685699839, 281813665,
    894450307, 364622641, 445105958, 869529743, 609327934, 216487201, 451174974,
    412524492, 165710904, 224442826, 343352203, 669384301, 184231419, 505683766,
    953200669, 532005284, 132807788, 809512374, 538094481, 468140312, 985445497,
    738978367, 584277426, 803430775, 908633407, 359907099, 145551833, 502510744,
    376619845, 271856184, 126444443, 111405238, 125436788, 576754065, 932360917,
    494332372, 296443191, 382604572, 416212877, 657940188, 962707672, 982571367,
    932344701, 522688084, 651637551, 719065069, 919619912, 118314052, 461133266,
    138848657, 820450592, 703467258, 98578715, 814944615, 937441733, 563045447,
    213962430, 161843630, 972618139, 480500447, 58943510, 554338849, 897313379,
    637575837, 808628930, 831904473, 782848402, 661072068, 703779082, 309409407,
    261040818, 931179908, 414023607, 558404991, 461431959, 699523175, 417458333,
    694347507, 823972037, 237978482, 108546846, 909167529, 210065669, 390173129,
    343736786, 581034415, 290036199, 223307516, 292579884, 340837267, 820925794,
    320550985, 444985426, 931897343, 476760409, 444920446, 790746490, 876646531,
    311828077, 472077335, 296882251, 616432721, 321277100, 365837527, 877200650,
    644328070, 116951230, 207085762, 947617825, 369597817, 886073491, 883722312,
    109972277, 744724249, 481514300, 547086940, 111314661, 41434849, 709489507,
    198748602, 154598019, 394494375, 716170113, 356682048, 530429936, 243888850,
    960317542, 807059021, 455819677, 142355532, 447540695, 104872690, 750375010,
    205312827, 123239181, 130799532, 555444467, 693362092, 716305972, 970009276,
    835559186, 884942984, 682306032, 758389005, 698254962, 869637665, 995361050,
    104011539, 322015620, 606619355, 401314413, 808050271, 756924730, 378365464,
    25000079, 120390435, 587599809, 729170355, 935018855, 104344198, 912679034,
    308901979, 718675969, 204011210, 187782364, 559824963, 563490169, 161233047,
    874627958, 637651814, 559798985, 669690369, 733080113, 206247899, 108518269,
    424493118, 661533914, 102210631, 45738331, 492026375, 624719292, 660994422,
    348865302, 490410133, 515815313, 310910129, 269247270, 964863060, 662466243,
    935501855, 978797795, 901305101, 464172346, 591361097, 777163647, 594941680,
    247729382, 75876759, 656951653, 231700944, 73471205, 895655700, 648180987,
    761100961, 475578989, 562669225, 287101462, 804900619, 594796925, 280096514,
    71145728, 41595713, 501862050, 330853082, 143710528, 555030352, 43910603,
    697854136, 40770657, 962639550, 377107615, 677178072, 638917686, 489073484,
    400425666, 582273539, 390255369, 768087204, 422077594, 495161238, 452858878,
    440215913, 60711903, 552187076, 39392920, 895434769, 809696148, 493746235,
    738892466, 304281117, 991799564, 381701450, 823227555, 65674335, 998239757,
    252185882, 882395239, 86847446, 522805069, 283660862, 957960142, 644587341,
    596368472, 302192909, 35683176, 420769735, 322433695, 252279213, 120333113,
    328597858, 368276252, 128870983, 909931822, 77569795, 251274010, 372389326,
    27752320, 847304496, 500716005, 735929832, 315265941, 259172160, 94266294,
    528204039, 235025941, 435007671, 179575002, 407480251, 830126215, 622749844,
    627756904, 853144910, 570169726, 984158754, 138140470, 329385015, 25823863,
    241909186, 71736282, 603772816, 565935196, 51072137, 232636346, 897525346,
    203996336, 476904370, 683849106, 80224506, 782164082, 861432746, 392798925,
    937029177, 335405502, 641457861, 389405376, 792591272, 481016005, 209407344,
    905118123, 651050440, 128465752, 264903499, 328049097, 856791161, 648723779,
    249248706, 8443182, 67916948, 990796476, 607099046, 805390643, 832705732,
    439459832, 474713153, 558561022, 379693035, 479324986, 602135315, 254884657,
    584275869, 522800537, 608644672, 244796117, 52241431, 869405706, 60665811,
    398276804, 461548766, 970920985, 681501327, 537380009, 322456456, 856165287,
    726650317, 711393862, 502427920, 462890283, 190242745, 744903798, 141780588,
    643467980, 281275982, 242672956, 649763021, 272359265, 769950012, 806629616,
    514540063, 120712522, 61141549, 24093650, 782361556, 862040224, 36735719,
    991865428, 852557033, 719068591, 981017948, 7200982, 736410373, 969570531,
    610251516, 496280303, 132306726, 223374772, 938736356, 287609336, 663736695,
    532248217, 62087333, 207864603, 553318931, 15614499, 849619280, 960845461,
    812290942, 10617931, 906255643, 813441282, 913771783, 383601550, 513897222,
    865227793, 704733686, 910068449, 348717754, 181305027, 885387022, 187681735,
    501002011, 946778749, 894769463, 409364404, 924062377, 209343617, 369739892,
    481509364, 689768189, 726430438, 823774653, 519962004, 526734798, 820826504,
    44300195, 503111429, 128502949, 924278154, 982478293, 270932701, 800396366,
    327802979, 950552352, 835637096, 140775684, 870185935, 657453422, 168009592,
    985528199, 457045206, 258489452, 577548433, 208606887, 270534952, 84460106,
    171785163, 836568184, 494656620, 281946991, 851129401, 817429820, 179270266,
    655294422, 363556730, 773838234, 528542850, 866785360, 315308908, 839218112,
    664558302, 41466518, 103231834, 481076552, 817919541, 464394659, 40612400,
    113111002, 78075164, 616813378, 243955774, 799618480, 593685438, 195354011,
    753606546, 974563453, 332442154, 70474831, 819721193, 268516279, 836797377,
    375852379, 553755547, 514297079, 655356485, 38478627, 401804841, 709201758,
    286187257, 761101860, 694378487, 708304001
};

const int numTableSize = sizeof(numTable) / sizeof(numTable[0]);

class TestHBtree: public QObject
{
    Q_OBJECT
public:
    TestHBtree();

private slots:
    void initTestCase();
    void cleanupTestCase();
    void init();
    void cleanup();

    void orderedList();
    void nodeComparisons();

    void openClose();
    void reopen();
    void reopenMultiple();
    void create();
    void putAndVerify_data();
    void putAndVerify();
    void testOverflow_data();
    void testOverflow();
    void addDeleteNodes_data();
    void addDeleteNodes();
    void last();
    void first();
    void insertRandom_200BytesTo1kValues();
    void insertHugeData_10Mb();
    void splitBranch_1kData();
    void splitBranchWithOverflows();
    void cursorExactMatch_data();
    void cursorExactMatch();
    void cursorEqualOrGreaterMatch_data();
    void cursorEqualOrGreaterMatch();
    void cursorEqualOrLessMatch_data();
    void cursorEqualOrLessMatch();
    void cursorWalk_data();
    void cursorWalk();
    void lastMultiPage();
    void firstMultiPage();
    void prev();
    void prev2();
    void multiBranchSplits_data();
    void multiBranchSplits();
    void rollback();
    void multipleRollbacks();
    void createWithCmp();
    void variableSizeKeysAndData_data();
    void variableSizeKeysAndData();
    void compareSequenceOfVarLengthKeys();
    void asciiAsSortedNumbers();
    void deleteReinsertVerify_data();
    void deleteReinsertVerify();
    void rebalanceEmptyTree();
    void reinsertion_data();
    void reinsertion();
    void tag();
    void cursors();
    void markerOnReopen_data();
    void markerOnReopen();
    void corruptSyncMarker1_data();
    void corruptSyncMarker1();
    void corruptBothSyncMarkers_data();
    void corruptBothSyncMarkers();
    void cursorWhileDelete_data();
    void cursorWhileDelete();
    void getDataFromLastSync();
    void deleteAlotNoSyncReopen_data();
    void deleteAlotNoSyncReopen();
    void customBlockSize();
    void clearData();

private:
    void setTestData(QList<int> itemCounts, QList<int> keySizes, QList<int> dataSizes, bool addCmpBool = false, bool addRandBool = false, bool addPreviousBool = false);
    void corruptSinglePage(int psize, int pgno = -1, qint32 type = -1);
    HBtree *db;
    HBtreePrivate *d;

    bool printOutCollectibles_;
    bool printExtraInfo_;
};

static const char dbname[] = "tst_HBtree.db";

const char * sizeStr(size_t sz)
{
    static char buffer[256];
    const size_t kb = 1024;
    const size_t mb = kb * kb;
    if (sz > mb) {
        sprintf(buffer, "%.2f mb", (float)sz / mb);
    } else if (sz > kb) {
        sprintf(buffer, "%.2f kb", (float)sz / kb);
    } else {
        sprintf(buffer, "%zu bytes", sz);
    }
    return buffer;
}

int myRand(int min, int max)
{
    float multiplier = (float)qrand() / (float)RAND_MAX;
    return (int)(multiplier * (float)(max - min)) + min;
}

int myRand(int r)
{
    return (int)(((float)qrand() / (float)RAND_MAX) * (float)r);
}


int asciiCmpFunc(const QByteArray &a, const QByteArray &b) {
//    qDebug() << a << b;
    int na = a.toInt();
    int nb = b.toInt();
    return na < nb ? -1 : (na > nb ? 1 : 0);
}

bool asciiCmpFuncForVec(const QByteArray &a, const QByteArray &b) {
    return asciiCmpFunc(a, b) < 0;
}

void newTestRow(QString name, int nItems, int szKeys, int szData, bool addCmpBool, bool addRandBool, bool addPreviousBool)
{
    if (addRandBool)
        Q_ASSERT(nItems <= numTableSize);

    QTest::newRow(name.toLatin1().constData()) << nItems << szKeys << szData << addCmpBool << addRandBool << addPreviousBool;
}

void makeTestRow(int nItems, int szKeys, int szData, bool addCmpBool, bool addRandBool, bool addPreviousBool)
{
    QString strItems = QString("%1 items").arg(nItems);
    QString strKeys = szKeys ? QString("%1 keys").arg(sizeStr(szKeys)) : "";
    QString strData = szData ? QString("%1 data").arg(sizeStr(szData)) : "";
    QString str = strItems;
    if (szKeys)
        str += QString(", ") + strKeys;
    if (szData)
        str += QString(", ") + strData;
    if (!addCmpBool && !addRandBool) {
        if (addPreviousBool) {
            QString strNext = str + " - cursorNext";
            QString strPrev = str + " - cursorPrev";
            newTestRow(strNext, nItems, szKeys, szData, false, false, false);
            newTestRow(strPrev, nItems, szKeys, szData, false, false, true);
        } else {
            newTestRow(str, nItems, szKeys, szData, false, false, false);
        }
    } else if (addCmpBool && addRandBool) {
        QString strContigiousWithCmp = str + " - contigious with cmp";
        QString strContigiousNoCmp = str + " - contigious without cmp";
        QString strRandomizedWithCmp = str + " - randomized with cmp";
        QString strRandomizedNoCmp = str + " - randomized without cmp";
        if (addPreviousBool) {
            QString withNext = " - cursorNext";
            QString withPrev = " - cursorPrev";
            newTestRow(strContigiousWithCmp + withNext, nItems, szKeys, szData, true, false, false);
            newTestRow(strContigiousNoCmp + withNext, nItems, szKeys, szData, false, false, false);
            newTestRow(strRandomizedWithCmp + withNext, nItems, szKeys, szData, true, true, false);
            newTestRow(strRandomizedNoCmp + withNext, nItems, szKeys, szData, false, true, false);
            newTestRow(strContigiousWithCmp + withPrev, nItems, szKeys, szData, true, false, true);
            newTestRow(strContigiousNoCmp + withPrev, nItems, szKeys, szData, false, false, true);
            newTestRow(strRandomizedWithCmp + withPrev, nItems, szKeys, szData, true, true, true);
            newTestRow(strRandomizedNoCmp + withPrev, nItems, szKeys, szData, false, true, true);
        } else {
            newTestRow(strContigiousWithCmp, nItems, szKeys, szData, true, false, false);
            newTestRow(strContigiousNoCmp, nItems, szKeys, szData, false, false, false);
            newTestRow(strRandomizedWithCmp, nItems, szKeys, szData, true, true, false);
            newTestRow(strRandomizedNoCmp, nItems, szKeys, szData, false, true, false);
        }
    } else if (addCmpBool) {
        QString strWithCmp = str + " - with cmp";
        QString strNoCmp = str + " - without cmp";
        if (addPreviousBool) {
            QString withNext = " - cursorNext";
            QString withPrev = " - cursorPrev";
            newTestRow(strWithCmp + withNext, nItems, szKeys, szData, true, false, false);
            newTestRow(strNoCmp + withNext, nItems, szKeys, szData, false, false, false);
            newTestRow(strWithCmp + withPrev, nItems, szKeys, szData, true, false, true);
            newTestRow(strNoCmp + withPrev, nItems, szKeys, szData, false, false, true);

        } else {
            newTestRow(strWithCmp, nItems, szKeys, szData, true, false, false);
            newTestRow(strNoCmp, nItems, szKeys, szData, false, false, false);
        }
    } else if (addRandBool) {
        QString strContigious = str + " - contigious";
        QString strRandomized = str + " - randomized";
        if (addPreviousBool) {
            QString withNext = " - cursorNext";
            QString withPrev = " - cursorPrev";
            newTestRow(strRandomized + withNext, nItems, szKeys, szData, false, true, false);
            newTestRow(strContigious + withNext, nItems, szKeys, szData, false, false, false);
            newTestRow(strRandomized + withPrev, nItems, szKeys, szData, false, true, true);
            newTestRow(strContigious + withPrev, nItems, szKeys, szData, false, false, true);
        } else {
            newTestRow(strRandomized, nItems, szKeys, szData, false, true, false);
            newTestRow(strContigious, nItems, szKeys, szData, false, false, false);
        }
    }
}

void TestHBtree::setTestData(QList<int> itemCounts, QList<int> keySizes, QList<int> dataSizes, bool addCmpBool, bool addRandBool, bool addPreviousBool)
{
    Q_ASSERT(itemCounts.size());

    QTest::addColumn<int>("numItems");
    QTest::addColumn<int>("keySize");
    QTest::addColumn<int>("valueSize");
    QTest::addColumn<bool>("useCmp");
    QTest::addColumn<bool>("randomize");
    QTest::addColumn<bool>("usePrevious");

    if (itemCounts.size() && keySizes.size() && dataSizes.size()) {
        foreach (int nItems, itemCounts) {
            foreach (int szKey, keySizes) {
                foreach (int szData, dataSizes)
                    makeTestRow(nItems, szKey, szData, addCmpBool, addRandBool, addPreviousBool);
            }
        }
    } else if (itemCounts.size() && keySizes.size()) {
        foreach (int nItems, itemCounts) {
            foreach (int szKey, keySizes)
                makeTestRow(nItems, szKey, 0, addCmpBool, addRandBool, addPreviousBool);
        }
    } else if (itemCounts.size() && dataSizes.size()) {
        foreach (int nItems, itemCounts) {
            foreach (int szData, dataSizes)
                makeTestRow(nItems, 0, szData, addCmpBool, addRandBool, addPreviousBool);
        }
    } else if (itemCounts.size()) {
         foreach (int nItems, itemCounts)
            makeTestRow(nItems, 0, 0, addCmpBool, addRandBool, addPreviousBool);
    }
}

void TestHBtree::corruptSinglePage(int psize, int pgno, qint32 type)
{
    const int asize = psize / 4;
    quint32 *page = new quint32[asize];
    QFile::OpenMode om = QFile::ReadWrite;

    if (pgno == -1)  // we'll be appending
        om |= QFile::Append;
    QFile file(dbname);
    QVERIFY(file.open(om));
    QVERIFY(file.seek((pgno == -1 ? 0 : pgno * psize)));
    QVERIFY(file.read((char*)page, asize));

    if (pgno == -1)
        pgno = file.size() / psize; // next pgno
    page[2] = pgno;
    if (type > 0)
        page[1] = type; // set page flag if specified

    for (int j = 3; j < asize; ++j) // randomly corrupt page (skip type and pgno)
        page[j] = rand();

    QVERIFY(file.seek(pgno * psize));
    QCOMPARE(file.write((char*)page, psize), (qint64)psize);
    file.close();

    delete [] page;
}

TestHBtree::TestHBtree()
    : db(NULL), printOutCollectibles_(true)
{
}

void TestHBtree::initTestCase()
{
}

void TestHBtree::cleanupTestCase()
{
}

void TestHBtree::init()
{
    QFile::remove(dbname);
    db = new HBtree(dbname);
    db->setAutoSyncRate(100);
    if (!db->open(HBtree::ReadWrite))
        Q_ASSERT(false);
    d = db->d_func();
    printOutCollectibles_ = true;
    printExtraInfo_ = false;
}

void TestHBtree::cleanup()
{
    if (printExtraInfo_) {
        qDebug() << "Size:" << sizeStr(db->size()) << " Pages:" << db->size() / d->spec_.pageSize;
        qDebug() << "Stats:" << db->stats();
        qDebug() << "Cache size:" << d->cache_.size();
        qDebug() << "Num collectibles:" << d->collectiblePages_.size();
        if (printOutCollectibles_)
            qDebug() << "Collectible pages: " << d->collectiblePages_;
    }

    delete db;
    db = 0;
    QFile::remove(dbname);
}

void TestHBtree::orderedList()
{
    OrderedList<HBtreePrivate::NodeKey, HBtreePrivate::NodeValue> list;

    typedef HBtreePrivate::NodeKey Key;
    typedef HBtreePrivate::NodeValue Value;

    Key key;

    key = Key(0, QByteArray("B"));
    list.insert(key, Value("_B_"));

    key = Key(0, QByteArray("A"));
    list.insert(key, Value("_A_"));

    key = Key(0, QByteArray("C"));
    list.insert(key, Value("_C_"));

    QCOMPARE(list.size(), 3);
    QVERIFY((list.constBegin() + 0).key().data == QByteArray("A"));
    QVERIFY((list.constBegin() + 1).key().data == QByteArray("B"));
    QVERIFY((list.constBegin() + 2).key().data == QByteArray("C"));

    QVERIFY(list.contains(Key(0, "A")));
    QVERIFY(!list.contains(Key(0, "AA")));
    QVERIFY(!list.contains(Key(0, "D")));

    QVERIFY(list.lowerBound(Key(0, "A")) == list.constBegin());
    QVERIFY(list.lowerBound(Key(0, "AA")) == list.constBegin()+1);
    QVERIFY(list.lowerBound(Key(0, "B")) == list.constBegin()+1);
    QVERIFY(list.lowerBound(Key(0, "D")) == list.constEnd());

    QVERIFY(list.upperBound(Key(0, "A")) == list.constBegin()+1);
    QVERIFY(list.upperBound(Key(0, "AA")) == list.constBegin()+1);
    QVERIFY(list.upperBound(Key(0, "B")) == list.constBegin()+2);
    QVERIFY(list.upperBound(Key(0, "D")) == list.constEnd());

    QCOMPARE(list.size(), 3);
    QVERIFY(list[Key(0, "C")].data == QByteArray("_C_"));
    QCOMPARE(list.size(), 3);
    list[Key(0, "C")].data = QByteArray("_C2_");
    QVERIFY(list[Key(0, "C")].data == QByteArray("_C2_"));
    QCOMPARE(list.size(), 3);
    QVERIFY(list[Key(0, "AA")].data.isEmpty());
    QVERIFY(list.contains(Key(0, "AA")));
    QCOMPARE(list.size(), 4);

    QVERIFY(list.find(Key(0, "D")) == list.constEnd());

    QCOMPARE(list.size(), 4);
    list.insert(Key(0, "B"), Value("_B2_"));
    QCOMPARE(list.size(), 4);

    QCOMPARE(list.value(Key(0, "A")).data, QByteArray("_A_"));
    QCOMPARE(list.value(Key(0, "B")).data, QByteArray("_B2_"));
    QCOMPARE(list.value(Key(0, "C")).data, QByteArray("_C2_"));
    QCOMPARE(list.value(Key(0, "AA")).data, QByteArray(""));
}

void TestHBtree::nodeComparisons()
{
    db->setCompareFunction(asciiCmpFunc);
    HBtreePrivate::NodeKey nkey10(d->compareFunction_, "10");
    HBtreePrivate::NodeKey nkey7(d->compareFunction_, "7");
    HBtreePrivate::NodeKey nkey33(d->compareFunction_, "33");

    QVERIFY(nkey10 > nkey7);
    QVERIFY(nkey33 > nkey7);
    QVERIFY(nkey33 > nkey10);

    QVERIFY(nkey10 != nkey7);
    QVERIFY(nkey33 != nkey7);
    QVERIFY(nkey33 != nkey10);

    QVERIFY(nkey7 < nkey10);
    QVERIFY(nkey7 < nkey33);
    QVERIFY(nkey10 < nkey33);

    QVERIFY(nkey10 == nkey10);

    QVERIFY(nkey7 <= nkey33);
    QVERIFY(nkey33 <= nkey33);

    QVERIFY(nkey33 >= nkey7);
    QVERIFY(nkey33 >= nkey33);
}

void TestHBtree::openClose()
{
    // init/cleanup does open and close;
    return;
}

void TestHBtree::reopen()
{
    db->close();
    QVERIFY(db->open());
    QCOMPARE(db->size(), (size_t)d->spec_.pageSize * 3);
}

void TestHBtree::reopenMultiple()
{
    const int numItems = 32;
    const int keySize = 64;
    const int valueSize = 64;
    QMap<QByteArray, QByteArray> keyValues;

    for (int i = 0; i < numItems; ++i) {
        QByteArray key = QString::number(i).toLatin1();
        if (key.size() < keySize)
            key += QByteArray(keySize - key.size(), '-');
        QByteArray value(valueSize, 'a' + i);
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(key, value));
        keyValues.insert(key, value);
        QVERIFY(transaction->commit(i));
    }

    const int retries = 5;

    for (int i = 0; i < retries; ++i) {
        db->close();
        db->open();
        QMap<QByteArray, QByteArray>::iterator it = keyValues.begin();
        while (it != keyValues.end()) {
            HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
            QVERIFY(transaction);
            QByteArray result = transaction->get(it.key());
            QCOMPARE(result, it.value());
            transaction->abort();
            ++it;
        }
    }
}

void TestHBtree::create()
{
    QByteArray key1("1");
    QByteArray value1("foo");
    QByteArray key2("2");
    QByteArray value2("bar");
    QByteArray key3("3");
    QByteArray value3("baz");

    QByteArray result;

    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    QVERIFY(txn->isReadWrite());

    // write first entry
    QVERIFY(txn->put(key1, value1));

    // read it
    result = txn->get(key1);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value1, result);

    // read non-existing entry
    result = txn->get(key2);
    QVERIFY(result.isEmpty());

    // write second entry
    QVERIFY(txn->put(key2, value2));

    // read both entries
    result = txn->get(key1);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value1, result);

    result = txn->get(key2);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value2, result);

    QVERIFY(txn->commit(42));
    QVERIFY(db->sync());

    txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(txn);
    QVERIFY(txn->isReadOnly());

    result = txn->get(key1);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value1, result);

    result = txn->get(key2);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value2, result);

    txn->abort();

    txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    QVERIFY(txn->isReadWrite());

    QVERIFY(txn->put(key3, value3));

    // read all
    result = txn->get(key1);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value1, result);

    result = txn->get(key2);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value2, result);

    result = txn->get(key3);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value3, result);

    QVERIFY(txn->commit(32));
    QVERIFY(db->sync());

    txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(txn);
    QVERIFY(txn->isReadOnly());

    result = txn->get(key1);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value1, result);

    result = txn->get(key2);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value2, result);

    result = txn->get(key3);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value3, result);

    txn->abort();

    txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    QVERIFY(txn->isReadWrite());

    QVERIFY(txn->remove(key2));

    result = txn->get(key1);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value1, result);

    result = txn->get(key2);
    QVERIFY(result.isEmpty());

    result = txn->get(key3);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value3, result);

    txn->commit(22);
    QVERIFY(db->sync());

    txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(txn);
    QVERIFY(txn->isReadOnly());

    result = txn->get(key1);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value1, result);

    result = txn->get(key2);
    QVERIFY(result.isEmpty());

    result = txn->get(key3);
    QVERIFY(!result.isEmpty());
    QCOMPARE(value3, result);

    txn->abort();
}

void TestHBtree::putAndVerify_data()
{
    QList<int> itemCounts = QList<int>() << 5 << 100 << 1000;
    QList<int> dataSizes = QList<int>() << 100 << 1000;
    setTestData(itemCounts, QList<int>(), dataSizes, false, true);
}

void TestHBtree::putAndVerify()
{
    QFETCH(int, numItems);
    QFETCH(int, valueSize);
    QFETCH(bool, randomize);
    const int numBytes = valueSize;

    for (int i = 0; i < numItems; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(QByteArray::number(randomize ? numTable[i] : i), QByteArray(numBytes, '0' + i)));
        QVERIFY(transaction->commit(i));
    }

    for (int i = 0; i < numItems; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(transaction);
        QCOMPARE(transaction->get(QByteArray::number(randomize ? numTable[i] : i)), QByteArray(numBytes, '0' + i));
        transaction->abort();
    }
}

void TestHBtree::testOverflow_data()
{
    QList<int> itemCounts = QList<int>() << 100 << 1000;
    QList<int> dataSizes = QList<int>() << 3000 << 20000;
    setTestData(itemCounts, QList<int>(), dataSizes);
}

void TestHBtree::testOverflow()
{
    QFETCH(int, numItems);
    QFETCH(int, valueSize);
    const int numBytes = valueSize;

    for (int i = 0; i < numItems; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(QString::number(i).toLatin1(), QByteArray(numBytes, '0' + i)));
        QVERIFY(transaction->commit(i));
    }

    for (int i = 0; i < numItems; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(transaction);
        QCOMPARE(transaction->get(QString::number(i).toLatin1()), QByteArray(numBytes, '0' + i));
        transaction->abort();
    }
}

void TestHBtree::addDeleteNodes_data()
{
    QList<int> itemCounts = QList<int>() << 100 << 1000;
    QList<int> dataSizes = QList<int>() << 200 << 1000 << 3000 << 5000;
    setTestData(itemCounts, QList<int>(), dataSizes, false, true);
}

void TestHBtree::addDeleteNodes()
{
    QFETCH(int, numItems);
    QFETCH(int, valueSize);
    QFETCH(bool, randomize);
    const int numBytes = valueSize;

    for (int i = 0; i < numItems; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(QByteArray::number(randomize ? numTable[i] : i), QByteArray(numBytes, '0' + i)));
        QVERIFY(transaction->commit(i));
        QCOMPARE(i + 1, db->stats().numEntries);
    }

    for (int i = 0; i < numItems; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->remove(QByteArray::number(randomize ? numTable[i] : i)));
        transaction->commit(i);
        QCOMPARE(numItems - i - 1, db->stats().numEntries);
    }

    for (int i = 0; i < numItems; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(transaction);
        QCOMPARE(transaction->get(QByteArray::number(randomize ? numTable[i] : i)), QByteArray());
        transaction->abort();
    }

    printOutCollectibles_ = false;
}
void TestHBtree::last()
{
    QByteArray key0("0");
    QByteArray value0("baz");
    QByteArray key1("1");
    QByteArray value1("foo");
    QByteArray key2("2");
    QByteArray value2("bar");

    HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
    // write first entry
    QVERIFY(transaction->put(key1, value1));

    // test cursor->last()
    {
        HBtreeCursor cursor(transaction);
        QVERIFY(cursor.last());
        QByteArray outkey1;
        cursor.current(&outkey1, 0);
        QCOMPARE(key1, outkey1);
    }

    // write second entry
    QVERIFY(transaction->put(key2, value2));

    // test cursor->last()
    {
        HBtreeCursor cursor(transaction);
        QVERIFY(cursor.last());
        QByteArray outkey2;
        cursor.current(&outkey2, 0);
        QCOMPARE(key2, outkey2);
    }

    // write zeroth entry
    QVERIFY(transaction->put(key0, value0));

    // test cursor->last()
    {
        HBtreeCursor cursor(transaction);
        QVERIFY(cursor.last());
        QByteArray outkey3;
        cursor.current(&outkey3, 0);
        QCOMPARE(key2, outkey3);
    }

    transaction->commit(42);
}

void TestHBtree::first()
{
    QByteArray key0("0");
    QByteArray value0("baz");
    QByteArray key1("1");
    QByteArray value1("foo");
    QByteArray key2("2");
    QByteArray value2("bar");

    HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
    // write first entry
    QVERIFY(transaction->put(key1, value1));

    // test cursor->last()
    {
        HBtreeCursor cursor(transaction);
        QVERIFY(cursor.first());
        QByteArray outkey1;
        cursor.current(&outkey1, 0);
        QCOMPARE(key1, outkey1);
    }

    // write second entry
    QVERIFY(transaction->put(key2, value2));

    // test cursor->last()
    {
        HBtreeCursor cursor(transaction);
        QVERIFY(cursor.first());
        QByteArray outkey2;
        cursor.current(&outkey2, 0);
        QCOMPARE(key1, outkey2);
    }

    // write zeroth entry
    QVERIFY(transaction->put(key0, value0));

    // test cursor->last()
    {
        HBtreeCursor cursor(transaction);
        QVERIFY(cursor.first());
        QByteArray outkey3;
        cursor.current(&outkey3, 0);
        QCOMPARE(key0, outkey3);
    }

    transaction->commit(42);
}

void TestHBtree::insertRandom_200BytesTo1kValues()
{
    const int numItems = 1000;
    QMap<QByteArray, QByteArray> keyValues;

    for (int i = 0; i < numItems; ++i) {
        QByteArray key = QString::number(qrand()).toLatin1();
        QByteArray value(myRand(200, 1000) , 'a' + i);
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(key, value));
        keyValues.insert(key, value);
        QVERIFY(transaction->commit(i));
    }

    QMap<QByteArray, QByteArray>::iterator it = keyValues.begin();
    while (it != keyValues.end()) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(transaction);
        QByteArray result = transaction->get(it.key());
        QCOMPARE(result, it.value());
        transaction->abort();
        ++it;
    }
}

void TestHBtree::insertHugeData_10Mb()
{
    QSKIP("This test takes too long");

    const int numBytes = 10000000;
    const int numItems = 100;
    for (int i = 0; i < numItems; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(QString::number(i).toLatin1(), QByteArray(numBytes, '0' + i)));
        QVERIFY(transaction->commit(i));
    }

    for (int i = 0; i < numItems; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(transaction);
        QCOMPARE(transaction->get(QString::number(i).toLatin1()), QByteArray(numBytes, '0' + i));
        transaction->abort();
    }
}

void TestHBtree::splitBranch_1kData()
{
    const int numItems = 5000; // must cause multiple branch splits
    const int valueSize = 1000;
    const int keySize = 16;
    QMap<QByteArray, QByteArray> keyValues;

    for (int i = 0; i < numItems; ++i) {
        QByteArray key = QString::number(i).toLatin1();
        if (key.size() < keySize)
            key += QByteArray(keySize - key.size(), '-');
        QByteArray value(valueSize, 'a' + i);
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(key, value));
        keyValues.insert(key, value);
        QVERIFY(transaction->commit(i));
    }

    QMap<QByteArray, QByteArray>::iterator it = keyValues.begin();
    while (it != keyValues.end()) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(transaction);
        QByteArray result = transaction->get(it.key());
        QCOMPARE(result, it.value());
        transaction->abort();
        ++it;
    }
}

void TestHBtree::splitBranchWithOverflows()
{
    // Bug, overflow pages get lost at a split.
    // This splits the page at the 308th insertion. The first
    // get transaction on a read fails after a split

    const int numItems = 1000; // must cause a split
    const int keySize = 255; // Only 3 1k keys can fit then we get a split
    const int valueSize = 4000; // must be over overflow threashold
    QMap<QByteArray, QByteArray> keyValues;

    for (int i = 0; i < numItems; ++i) {
        QByteArray key = QString::number(i).toLatin1();
        if (key.size() < keySize)
            key += QByteArray(keySize - key.size(), '-');
        QByteArray value(valueSize, 'a' + i);
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(key, value));
        keyValues.insert(key, value);
        QVERIFY(transaction->commit(i));
    }

    QMap<QByteArray, QByteArray>::iterator it = keyValues.begin();
    while (it != keyValues.end()) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(transaction);
        QByteArray result = transaction->get(it.key());
        QCOMPARE(result, it.value());
        transaction->abort();
        ++it;
    }

}

void TestHBtree::cursorExactMatch_data()
{
    QList<int> itemCounts = QList<int>() << 5 << 100 << 1000;
    QList<int> dataSizes = QList<int>() << 100 << 1000 << 3000;
    setTestData(itemCounts, QList<int>(), dataSizes, false, true);
}

void TestHBtree::cursorExactMatch()
{
    QFETCH(int, numItems);
    QFETCH(int, valueSize);
    QFETCH(bool, randomize);

    QMap<QByteArray, QByteArray> keyValues;

    for (int i = 0; i < numItems; ++i) {
        QByteArray key = QByteArray::number(randomize ? numTable[i] : i);
        QByteArray value = key + QByteArray('-', valueSize - key.size());
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(key, value));
        keyValues.insert(key, value);
        QVERIFY(transaction->commit(i));
    }

    HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
    HBtreeCursor cursor(transaction);
    QMap<QByteArray, QByteArray>::iterator it = keyValues.begin();

    while (it != keyValues.end()) {
        QVERIFY(cursor.seek(it.key()));
        QCOMPARE(cursor.key(), it.key());
        QCOMPARE(cursor.value(), it.value());
        ++it;
    }

    transaction->abort();
}

void TestHBtree::cursorEqualOrGreaterMatch_data()
{
    QList<int> itemCounts = QList<int>() << 5 << 100 << 1000;
    QList<int> dataSizes = QList<int>() << 100 << 1000 << 3000;
    setTestData(itemCounts, QList<int>(), dataSizes, false, false);
}

void TestHBtree::cursorEqualOrGreaterMatch()
{
    QFETCH(int, numItems);
    QFETCH(int, valueSize);

    QMap<QByteArray, QByteArray> keyValues;

    // Subtract 3 to leave some room to check for keys that are not equal or greater
    for (int i = 0; i < numItems - 3; ++i) {
        QByteArray key = QByteArray::number(i * 2);
        QByteArray value = key + QByteArray('-', valueSize - key.size());
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(key, value));
        keyValues.insert(key, value);
        QVERIFY(transaction->commit(i));
    }

    HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
    HBtreeCursor cursor(transaction);
    for (int i = 0; i < numItems * 2; ++i) {
        QByteArray ba = QByteArray::number(i);
        bool ok = cursor.seekRange(ba);
        QMap<QByteArray, QByteArray>::iterator it = keyValues.lowerBound(ba);

        if (it == keyValues.end()) {
            QVERIFY(!ok);
        } else {
            QCOMPARE(cursor.key(), it.key());
            QCOMPARE(cursor.value(), it.value());
        }
    }

    transaction->abort();
}

void TestHBtree::cursorEqualOrLessMatch_data()
{
    QList<int> itemCounts = QList<int>() << 5 << 100 << 1000;
    QList<int> dataSizes = QList<int>() << 100 << 1000 << 3000;
    setTestData(itemCounts, QList<int>(), dataSizes, false, false);
}

void TestHBtree::cursorEqualOrLessMatch()
{
    QFETCH(int, numItems);
    QFETCH(int, valueSize);

    QMap<QByteArray, QByteArray> keyValues;

    // Start at 3 so that we can leave room for checking when there is no key equal or less
    for (int i = 3; i < numItems; ++i) {
        QByteArray key = QByteArray::number(i * 2);
        QByteArray value = key + QByteArray('-', valueSize - key.size());
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(key, value));
        keyValues.insert(key, value);
        QVERIFY(transaction->commit(i));
    }

    HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
    HBtreeCursor cursor(transaction);
    for (int i = 0; i < numItems * 2; ++i) {
        QByteArray ba = QByteArray::number(i);
        bool ok = cursor.seekRange(ba, HBtreeCursor::EqualOrLess);
        QMap<QByteArray, QByteArray>::iterator it = keyValues.lowerBound(ba);

        if (it == keyValues.end() || (it != keyValues.begin() && it.key() > ba))
            --it;

        if (it.key() > ba) {
            QVERIFY(!ok);
        } else {
            QCOMPARE(cursor.key(), it.key());
            QCOMPARE(cursor.value(), it.value());
        }
    }

    transaction->abort();
}

void TestHBtree::cursorWalk_data()
{
    QList<int> itemCounts = QList<int>() << 5 << 100 << 1000;
    QList<int> dataSizes = QList<int>() << 100 << 1000 << 3000;
    setTestData(itemCounts, QList<int>(), dataSizes, false, true, true);
}

void TestHBtree::cursorWalk()
{
    QFETCH(int, numItems);
    QFETCH(int, valueSize);
    QFETCH(bool, randomize);
    QFETCH(bool, usePrevious);

    QMap<QByteArray, QByteArray> keyValues;

    for (int i = 0; i < numItems; ++i) {
        QByteArray key = QByteArray::number(randomize ? numTable[i] : i);
        QByteArray value = key + QByteArray('-', valueSize - key.size());
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(key, value));
        keyValues.insert(key, value);
        QVERIFY(transaction->commit(i));
    }

    HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
    HBtreeCursor cursor(transaction);
    QMap<QByteArray, QByteArray>::iterator it = usePrevious ? keyValues.end() - 1 : keyValues.begin();

    while (it != keyValues.end()) {
        if (usePrevious)
            QVERIFY(cursor.previous());
        else
            QVERIFY(cursor.next());
        QCOMPARE(cursor.key(), it.key());
        QCOMPARE(cursor.value(), it.value());
        if (usePrevious) {
            if (it == keyValues.constBegin())
                break;
            --it;
        } else {
            ++it;
        }
    }

    transaction->abort();
}

void TestHBtree::lastMultiPage()
{
    QByteArray value0("baz");

    for (int i = 0; i < 1024; i++) {
        // write first entry
        QByteArray baKey(4, 0);
        qToBigEndian(i, (uchar *)baKey.data());
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);
        QVERIFY(txn->put(baKey, value0));
        QVERIFY(txn->commit(0));

        txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(txn);
        HBtreeCursor cursor(txn);
        QVERIFY(cursor.last());
        QByteArray outkey1;
        cursor.current(&outkey1, 0);
        QCOMPARE(baKey, outkey1);
        while (cursor.previous()) {
            QByteArray outkey2;
            cursor.current(&outkey2, 0);
            QVERIFY(memcmp(outkey1.constData(), outkey2.constData(), outkey1.size()) > 0);
            outkey1 = outkey2;
        }
        txn->abort();
    }
}

void TestHBtree::firstMultiPage()
{
    QByteArray value0("baz");

    for (int i = 1024; i > 0; i--) {
        // write first entry
        QByteArray baKey(4, 0);
        qToBigEndian(i, (uchar *)baKey.data());
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);
        QVERIFY(txn->put(baKey, value0));
        QVERIFY(txn->commit(0));

        txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(txn);
        HBtreeCursor cursor(txn);
        QVERIFY(cursor.first());
        QByteArray outkey1;
        cursor.current(&outkey1, 0);
        QCOMPARE(baKey, outkey1);
        while (cursor.next()) {
            QByteArray outkey2;
            cursor.current(&outkey2, 0);
            QVERIFY(memcmp(outkey1.constData(), outkey2.constData(), outkey1.size()) < 0);
            outkey1 = outkey2;
        }
        txn->abort();
    }
}

void TestHBtree::prev()
{
    QByteArray key0("0");
    QByteArray value0("baz");
    QByteArray key1("1");
    QByteArray value1("foo");
    QByteArray key2("2");
    QByteArray value2("bar");

    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    // write entries
    QVERIFY(txn->put(key0, value0));
    QVERIFY(txn->put(key1, value1));
    QVERIFY(txn->put(key2, value2));

    // go to end
    {
        HBtreeCursor cursor(txn);
        QVERIFY(cursor.last());
        // test prev
        QVERIFY(cursor.previous());
        QByteArray outkey;
        cursor.current(&outkey, 0);
        QCOMPARE(key1, outkey);
    }

    {
        HBtreeCursor cursor(txn);
        // test prev without initialization is same as last()
        QVERIFY(cursor.previous());
        QByteArray outkey;
        cursor.current(&outkey, 0);
        QCOMPARE(key2, outkey);

        // prev to key1
        QVERIFY(cursor.previous());
        cursor.current(&outkey, 0);
        QCOMPARE(key1, outkey);

        // prev to key0
        QVERIFY(cursor.previous());
        cursor.current(&outkey, 0);
        QCOMPARE(key0, outkey);

        // prev to eof
        QVERIFY(!cursor.previous());
    }
    txn->abort();
}

void TestHBtree::prev2()
{
    QFile file(dbname);
    int maxSize = file.size();

    int amount = ::getenv("BENCHMARK_AMOUNT") ? ::atoi(::getenv("BENCHMARK_AMOUNT")) : 40000;
    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    for (int i = 0; i < amount; ++i) {
        QByteArray data = QUuid::createUuid().toRfc4122();
        QVERIFY(txn->put(data, QByteArray("value_")+QByteArray::number(i)));
        int size = file.size();
        if (size > maxSize)
            maxSize = size;
    }
    txn->commit(0);

    txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(txn);
    HBtreeCursor c(txn);
    QVERIFY(c.first());
    int cnt = 1;
    while (c.next()) ++cnt;
    QCOMPARE(cnt, amount);

    HBtreeCursor r(txn);
    QVERIFY(r.last());
    int rcnt = 1;
    while (r.previous()) ++rcnt;

    QCOMPARE(rcnt, amount);
    txn->abort();
}

bool multiBranchInsertData(HBtree *db, QMap<QByteArray, QByteArray> keyValues)
{
    QMap<QByteArray, QByteArray>::const_iterator it = keyValues.constBegin();
    int i = 0;
    while (it != keyValues.constEnd()) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        if (!transaction)
            return false;
        if (!transaction->put(it.key(), it.value()))
            return false;
        if (!transaction->commit(i++))
            return false;
        ++it;
    }
    return true;
}

void TestHBtree::multiBranchSplits_data()
{
    QList<int> itemCounts = QList<int>() << 3000;
    QList<int> keySizes = QList<int>() << 512;
    QList<int> dataSizes = QList<int>() << 1000;
    setTestData(itemCounts, keySizes, dataSizes, false, true);
}

void TestHBtree::multiBranchSplits()
{
    QFETCH(int, numItems);
    QFETCH(int, valueSize);
    QFETCH(int, keySize);
    QFETCH(bool, randomize);

    // Make keys and values
    QMap<QByteArray, QByteArray> keyValues;
    for (int i = 0; i < numItems; ++i) {
        QByteArray key = QByteArray::number(randomize ? numTable[i] : i);
        if (key.size() < keySize)
            key += QByteArray(keySize - key.size(), '-');
        QByteArray value(valueSize, 'a' + i);
        keyValues.insert(key, value);
    }

    QList<QByteArray> keys = keyValues.keys();

    do {
        // Insert all
        multiBranchInsertData(db, keyValues);

        // Verify all
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
        foreach (QByteArray key, keys)
            QCOMPARE(transaction->get(key), keyValues[key]);
        transaction->abort();

        // Remove all in permuted order
        foreach (QByteArray key, keys) {
            transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
            QVERIFY(transaction->remove(key));
            transaction->commit(999999);
        }

//        QList<QByteArray> copy = keys;
//        for (int i = 0; i < copy.size(); ++i)
//            copy[i] = copy[i].left(10);
//        qDebug() << "removed" << copy;
    } while (0 /*std::next_permutation(keys.begin(), keys.end())*/);

    printOutCollectibles_ = false;
}

int keyCmp(const QByteArray &a, const QByteArray &b)
{
    QString as((const QChar*)a.constData(), a.size() / 2);
    QString bs((const QChar*)b.constData(), b.size() / 2);
    if (as < bs)
        return -1;
    else if (as > bs)
        return 1;
    else
        return 0;
}

void TestHBtree::createWithCmp()
{
    db->setCompareFunction(keyCmp);
    QString str1("1");
    QByteArray key1 = QByteArray::fromRawData((const char *)str1.data(), str1.size()*2);
    QByteArray value1("foo");
    QString str2("2");
    QByteArray key2 = QByteArray::fromRawData((const char *)str2.data(), str2.size()*2);
    QByteArray value2("bar");

    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);

    // write first entry
    QVERIFY(txn->put(key1, value1));

    // read it
    QCOMPARE(value1, txn->get(key1));

    // read non-existing entry
    QVERIFY(txn->get(key2).isEmpty());

    // write second entry
    QVERIFY(txn->put(key2, value2));

    // read both entries
    QCOMPARE(value1, txn->get(key1));
    QCOMPARE(value2, txn->get(key2));

    txn->abort();
}

void TestHBtree::rollback()
{
    QByteArray key1("22");
    QByteArray value1("foo");
    QByteArray key2("42");
    QByteArray value2("bar");

    QByteArray result;

    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    // write first entry
    QVERIFY(txn->put(key1, value1));
    txn->commit(42);

    {
        // start transaction
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);

        // re-write the first entry
        QVERIFY(txn->remove(key1));

        QVERIFY(txn->put(key1, value2));

        // write second entry
        QVERIFY(txn->put(key2, value2));

        // abort the transaction
        txn->abort();
    }

    txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(txn);

    // read both entries
    QCOMPARE(value1, txn->get(key1));

    QVERIFY(txn->get(key2).isEmpty());

    txn->abort();
}

void TestHBtree::multipleRollbacks()
{
    QByteArray key1("101");
    QByteArray value1("foo");
    QByteArray key2("102");
    QByteArray value2("bar");

    {
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);
        // write first entry
        QVERIFY(txn->put(key1, value1));
        QVERIFY(txn->commit(0));
    }

    {
        // start transaction
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);

        // re-write the first entry
        QVERIFY(txn->remove(key1));
        QVERIFY(txn->put(key1, value2));

        // abort the transaction
        txn->abort();
    }

    {
        // start transaction
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);

        // write second entry
        QVERIFY(txn->put(key2, value2));

        // abort the transaction
        txn->abort();
    }

    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadOnly);

    // read both entries
    QCOMPARE(value1, txn->get(key1));
    QVERIFY(txn->get(key2).isEmpty());
    txn->abort();
}

void TestHBtree::variableSizeKeysAndData_data()
{
    QList<int> itemCounts = QList<int>() << 1000;
    setTestData(itemCounts, QList<int>(), QList<int>(), false, false, true);
}

void TestHBtree::variableSizeKeysAndData()
{
    QFETCH(int, numItems);
    QFETCH(bool, usePrevious);

    QByteArray keyPrefix[10] = {
        QByteArray("0001234567890123456789"),
        QByteArray("000123456789"),
        QByteArray("00012345678"),
        QByteArray("0001234567"),
        QByteArray("000123456"),
        QByteArray("00012345"),
        QByteArray("0001234"),
        QByteArray("000123"),
        QByteArray("00012"),
        QByteArray("1")};

    /* initialize random seed: */
    srand ( 0 ); //QDateTime::currentMSecsSinceEpoch() );

    for (int i = 0; i < numItems; i++) {
        // Create a key with one of the prefixes from above
        // Start by selecting one of the key prefixes
        QByteArray key = keyPrefix[rand()%10];
        int length = rand() % 128 + 1;
        QByteArray keyPostfix(length, ' ');
        for (int j=0; j<length; j++) {
            keyPostfix[j] = quint8(rand()%255);
        }
        key += keyPostfix;

        length = rand() % 1024 + 1;
        // Create a random length value with random bytes
        QByteArray value(length, ' ');
        for (int j=0; j<length; j++) {
            value[j] = quint8(rand()%255);
        }
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);
        QVERIFY(txn->put(key, value));
        QVERIFY(txn->commit(0));
    }
    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    // Delete every second object
    HBtreeCursor cursor(txn);
    QVERIFY(usePrevious ? cursor.last() : cursor.first());
    QByteArray key;
    cursor.current(&key, 0);
    bool remove = true;
    int counter = 0;
    while (usePrevious ? cursor.previous() : cursor.next()) {
        counter++;
        if (remove) {
            remove = false;
            QVERIFY(txn->remove(cursor.key()));
        }
        else remove = true;
    }
    txn->commit(0);
}

int findLongestSequenceOf(const char *a, size_t size, char x)
{
    int result = 0;
    int count = 0;
    for (size_t i = 0; i < size; ++i) {
        if (count > result)
            result = count;

        if (count) {
            if (a[i] == x)
                count++;
            else
                count = 0;
            continue;
        }

        count = a[i] == x ? 1 : 0;
    }

    if (count > result)
        result = count;

    return result;
}

int cmpVarLengthKeys(const QByteArray &a, const QByteArray &b)
{
    int acount = findLongestSequenceOf(a.constData(), a.size(), 'a');
    int bcount = findLongestSequenceOf(b.constData(), b.size(), 'a');

    if (acount == bcount) {
        return QString::compare(a, b);
    } else {
        return (acount > bcount) ? 1 : ((acount < bcount) ? -1 : 0);
    }
}

bool cmpVarLengthKeysForQVec(const QByteArray &a, const QByteArray &b)
{
    return cmpVarLengthKeys(a, b) < 0;
}


void TestHBtree::compareSequenceOfVarLengthKeys()
{
    const char sequenceChar = 'a';
    const int numElements = 1024;
    const int minKeyLength = 20;
    const int maxKeyLength = 25;

    db->setCompareFunction(cmpVarLengthKeys);

    // Create vector of variable length keys of sequenceChar
    QVector<QByteArray> vec;
    for (int i = 0; i < numElements; ++i) {
        QByteArray k(minKeyLength + myRand(maxKeyLength - minKeyLength), sequenceChar);

        // Change character at random indexed
        for (int j = 0; j < k.size(); ++j) {
            if (myRand(2) > 0)
                k[j] = 'a' + myRand(26);
        }
        vec.append(k);
    }

    for (int i = 0; i < vec.size(); ++i) {
        int count = findLongestSequenceOf(vec[i].constData(), vec[i].size(), sequenceChar);
        QByteArray value((const char*)&count, sizeof(count));
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);
        QVERIFY(txn->put(vec[i], vec[i]));
        QVERIFY(txn->commit(i));
    }

    // Sort QVector to use as verification of bdb sort order
    qSort(vec.begin(), vec.end(), cmpVarLengthKeysForQVec);

    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(txn);
    HBtreeCursor cursor(txn);

    QByteArray key;
    QByteArray value;
    int i = 0;
    while (cursor.next()) {
        cursor.current(&key, 0);
        cursor.current(0, &value);
        QCOMPARE(key, vec[i++]);
    }
    txn->abort();
}

void TestHBtree::asciiAsSortedNumbers()
{
    const int numItems = 1000;
    QVector<QByteArray> keys;

    db->setCompareFunction(asciiCmpFunc);

    for (int i = 0; i < numItems; ++i) {
        QByteArray key = QString::number(qrand()).toLatin1();
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(key, key));
        keys.append(key);
        QVERIFY(transaction->commit(i));
    }

    qSort(keys.begin(), keys.end(), asciiCmpFuncForVec);

    HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(transaction);
    HBtreeCursor cursor(transaction);
    QVector<QByteArray>::iterator it = keys.begin();
    while (it != keys.end()) {
        QVERIFY(cursor.next());
        QCOMPARE(cursor.key(), *it);
        QCOMPARE(cursor.value(),*it);
        ++it;
    }
    transaction->abort();
}

void TestHBtree::deleteReinsertVerify_data()
{
    QList<int> itemCounts = QList<int>() << 100 << 1000 << 2000;
    setTestData(itemCounts, QList<int>(), QList<int>(), true, true, true);
}

void TestHBtree::deleteReinsertVerify()
{
    QFETCH(int, numItems);
    QFETCH(bool, randomize);
    QFETCH(bool, useCmp);
    QFETCH(bool, usePrevious);

    if (useCmp)
        db->setCompareFunction(asciiCmpFunc);


    QVector<QByteArray> keys;
    QMap<QByteArray, QByteArray> keyValueMap;
    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    for (int i = 0; i < numItems; ++i) {
        QByteArray key = QByteArray::number(randomize ? numTable[i] : i);
        QByteArray value = QByteArray::number(rand());
        keys.append(key);
        keyValueMap.insert(key, value);
        QVERIFY(txn->put(key, value));
    }
    QVERIFY(txn->commit(100));

    if (useCmp)
        qSort(keys.begin(), keys.end(), asciiCmpFuncForVec);
    else
        qSort(keys); // sort by qbytearray oeprator < since that's default in HBtree

    QCOMPARE(keyValueMap.size(), db->count());

    // Remove every other key
    txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    QMap<QByteArray, QByteArray> removedKeyValues;
    for (int i = 0; i < numItems; i += 2) {
        int idx = i;
        QByteArray removedValue = keyValueMap[keys[idx]];
        QCOMPARE(keyValueMap.remove(keys[idx]), 1);
        removedKeyValues.insert(keys[idx], removedValue);
        QVERIFY(txn->remove(keys[idx]));
    }
    QVERIFY(txn->commit(200));

    // Verify
    txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QMap<QByteArray, QByteArray>::iterator it = keyValueMap.begin();
    while (it != keyValueMap.end()) {
        QCOMPARE(txn->get(it.key()), it.value());
        ++it;
    }
    it = removedKeyValues.begin();
    while (it != removedKeyValues.end()) {
        QCOMPARE(txn->get(it.key()), QByteArray());
        ++it;
    }
    txn->abort();

    // Reinsert
    txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    it = removedKeyValues.begin();
    while (it != removedKeyValues.end()) {
        QVERIFY(txn->put(it.key(), it.value()));
        keyValueMap.insert(it.key(), it.value());
        ++it;
    }
    txn->commit(0);

    // Verify in order.
    txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(txn);
    HBtreeCursor cursor(txn);
    for (int i = 0; i < numItems; ++i) {
        if (usePrevious)
            QVERIFY(cursor.previous());
        else
            QVERIFY(cursor.next());
        int idx = usePrevious ? (numItems - 1) - i : i;
        it = keyValueMap.find(keys[idx]);
        QVERIFY(it != keyValueMap.end());
        QCOMPARE(cursor.key(), keys[idx]);
        QCOMPARE(cursor.value(), it.value());
    }
    txn->abort();

}

void TestHBtree::rebalanceEmptyTree()
{
    QByteArray k1("foo");
    QByteArray v1("bar");
    QByteArray k2("ding");
    QByteArray v2("dong");
    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    QVERIFY(txn->put(k1, v1));
    QVERIFY(txn->commit(0));

    txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    QCOMPARE(txn->get(k1), v1);
    QVERIFY(txn->remove(k1));
    QVERIFY(txn->get(k1).isEmpty());
    QVERIFY(txn->commit(0));

    txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    QVERIFY(txn->get(k1).isEmpty());
    QVERIFY(txn->put(k2, v2));
    QCOMPARE(txn->get(k2), v2);
    QVERIFY(txn->commit(0));

    txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    QVERIFY(txn->remove(k2));
    QVERIFY(txn->commit(0));

    txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(txn);
    QVERIFY(txn->get(k1).isEmpty());
    QVERIFY(txn->get(k2).isEmpty());
    QVERIFY(txn->commit(0));
}

void TestHBtree::reinsertion_data()
{
    QList<int> itemCounts = QList<int>() << 100 << 1000 << 2000;
    setTestData(itemCounts, QList<int>(), QList<int>(), false, true);
}

void TestHBtree::reinsertion()
{
    QFETCH(int, numItems);
    QFETCH(bool, randomize);
    QMap<QByteArray, QByteArray> keyValues;

    for (int i = 0; i < numItems; ++i) {
        QByteArray key = QByteArray::number(randomize ? numTable[i] : i);
        QByteArray value(myRand(200, 1000) , 'a' + i);
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(key, value));
        keyValues.insert(key, value);
        QVERIFY(transaction->commit(i));
    }

    QMap<QByteArray, QByteArray>::iterator it = keyValues.begin();
    while (it != keyValues.end()) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(transaction);
        QByteArray result = transaction->get(it.key());
        QCOMPARE(result, it.value());
        transaction->abort();
        ++it;
    }

    for (int i = 0; i < numItems * 2; ++i) {
        it = keyValues.begin() + myRand(0, numItems);
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(it.key(), it.value()));
        QVERIFY(transaction->commit(i));
    }

    it = keyValues.begin();
    while (it != keyValues.end()) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(transaction);
        QByteArray result = transaction->get(it.key());
        QCOMPARE(result, it.value());
        transaction->abort();
        ++it;
    }
}

void TestHBtree::tag()
{
    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    QVERIFY(txn->put(QByteArray("foo"), QByteArray("123")));
    QVERIFY(txn->commit(42u));

    txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    QVERIFY(txn->put(QByteArray("foo"), QByteArray("123")));
    QCOMPARE(db->tag(), 42u);

    // This test held off on a commit until the read was done. But for now we don't allow
    // simultaneous reads and writes.
    txn->abort();

    HBtreeTransaction *rtxn = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(rtxn);
    QCOMPARE(rtxn->tag(), 42u);
    rtxn->abort();

    txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    QVERIFY(txn->commit(64u));
    QCOMPARE(db->tag(), 64u);

    rtxn = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(rtxn);
    QCOMPARE(rtxn->tag(), 64u);
    rtxn->abort();
}

void TestHBtree::cursors()
{
    QSKIP("cursor copy ctors not implemented yet");

    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    txn->put(QByteArray("1"), QByteArray("a"));
    txn->put(QByteArray("2"), QByteArray("b"));
    txn->put(QByteArray("3"), QByteArray("c"));
    txn->put(QByteArray("4"), QByteArray("d"));
    txn->commit(0);

    txn = db->beginRead();

    QByteArray k1, k2;
    HBtreeCursor c1;
    HBtreeCursor c2(txn);

    c2.first();
    c2.current(&k1, 0);
    QCOMPARE(k1, QByteArray("1"));

    c2.next();
    c2.current(&k1, 0);
    QCOMPARE(k1, QByteArray("2"));

    c1 = c2;
    c1.current(&k1, 0);
    c2.current(&k2, 0);
    QCOMPARE(k1, k2);

    c1.next();
    c1.current(&k1, 0);
    c2.current(&k2, 0);
    QCOMPARE(k1, QByteArray("3"));
    QCOMPARE(k2, QByteArray("2"));

    HBtreeCursor c3(c1);
    c3.next();
    c1.current(&k1, 0);
    c3.current(&k2, 0);
    QCOMPARE(k1, QByteArray("3"));
    QCOMPARE(k2, QByteArray("4"));

    txn->abort();
}

void TestHBtree::markerOnReopen_data()
{
    // This test won't work if numCommits results in an auto sync or a split
    QTest::addColumn<quint32>("numCommits");
    QTest::newRow("Even commits") << 10u;
    QTest::newRow("Odd Commits") << 13u;
}

void TestHBtree::markerOnReopen()
{
    QFETCH(quint32, numCommits);
    const quint32 pageSize = d->spec_.pageSize;

    for (quint32 i = 0; i < numCommits; ++i) {
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);
        QVERIFY(txn->put(QByteArray::number(i), QByteArray::number(i)));
        QVERIFY(txn->commit(i));
    }

    QCOMPARE(d->marker_.info.number, 1u);
    QCOMPARE(d->collectiblePages_.size(), 0);
    QCOMPARE(d->size_, quint32(pageSize * 4));
    QCOMPARE(d->marker_.meta.revision, numCommits);
    QCOMPARE(d->marker_.meta.syncId, 1u);
    QCOMPARE(d->marker_.meta.root, 3u);
    QCOMPARE(d->marker_.meta.tag, (quint64)numCommits - 1);

    db->close();
    QVERIFY(db->open());

    QCOMPARE(d->marker_.info.number, 1u);
    QCOMPARE(d->collectiblePages_.size(), 0);
    QCOMPARE(d->size_, quint32(pageSize * 4));
    QCOMPARE(d->marker_.meta.revision, numCommits);
    QCOMPARE(d->marker_.meta.syncId, 1u);
    QCOMPARE(d->marker_.meta.root, 3u);
    QCOMPARE(d->marker_.meta.tag, (quint64)numCommits - 1);

    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    QVERIFY(txn->put(QByteArray::number(1000), QByteArray("1000")));
    QVERIFY(txn->commit(1000));

    // Synced page should not be used
    QCOMPARE(d->marker_.info.number, 1u);
    QCOMPARE(d->collectiblePages_.size(), 0);
    QCOMPARE(d->size_, quint32(pageSize * 5));
    QCOMPARE(d->marker_.meta.revision, numCommits + 1);
    QCOMPARE(d->marker_.meta.syncId, 2u);
    QCOMPARE(d->marker_.meta.root, 4u);
    QCOMPARE(d->marker_.meta.tag, (quint64)1000);

    QVERIFY(db->sync());

    txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    QVERIFY(txn->put(QByteArray::number(2000), QByteArray("2000")));
    QVERIFY(txn->commit(2000));

    QCOMPARE(d->marker_.info.number, 1u);
    QCOMPARE(d->collectiblePages_.size(), 0);
    QCOMPARE(d->size_, quint32(pageSize * 5));
    QCOMPARE(d->marker_.meta.revision, numCommits + 2);
    QCOMPARE(d->marker_.meta.syncId, 3u);
    QCOMPARE(d->marker_.meta.root, 3u);
    QCOMPARE(d->marker_.meta.tag, (quint64)2000);
}

void TestHBtree::corruptSyncMarker1_data()
{
    QTest::addColumn<quint32>("numCommits");
    QTest::newRow("Even commits") << 10u;
    QTest::newRow("Odd Commits") << 13u;
}

void TestHBtree::corruptSyncMarker1()
{
    QFETCH(quint32, numCommits);

    quint32 psize = d->spec_.pageSize;
    for (quint32 i = 0; i < numCommits; ++i) {
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);
        QVERIFY(txn->put(QByteArray::number(i), QByteArray::number(i)));
        QVERIFY(txn->commit(i));
    }

    QCOMPARE(d->collectiblePages_.size(), 0);

    for (int i = 0; i < 5; ++i) {
        db->close();

        corruptSinglePage(psize, 1, HBtreePrivate::PageInfo::Marker);

        QVERIFY(db->open());

        QCOMPARE(d->collectiblePages_.size(), 0);

        for (quint32 i = 0; i < numCommits; ++i) {
            HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
            QVERIFY(txn);
            QCOMPARE(txn->get(QByteArray::number(i)), QByteArray::number(i));
            txn->abort();
        }
    }
}

void TestHBtree::corruptBothSyncMarkers_data()
{
    QTest::addColumn<quint32>("numCommits");
    QTest::newRow("Even commits") << 10u;
    QTest::newRow("Odd Commits") << 13u;
}

void TestHBtree::corruptBothSyncMarkers()
{
    QFETCH(quint32, numCommits);

    quint32 psize = d->spec_.pageSize;
    for (quint32 i = 0; i < numCommits; ++i) {
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);
        QVERIFY(txn->put(QByteArray::number(i), QByteArray::number(i)));
        QVERIFY(txn->commit(i));
    }

    for (int i = 0; i < 1; ++i) {
        db->close();

        corruptSinglePage(psize, 1, HBtreePrivate::PageInfo::Marker);
        corruptSinglePage(psize, 2, HBtreePrivate::PageInfo::Marker);

        QVERIFY(!db->open());
    }
}

void TestHBtree::cursorWhileDelete_data()
{
    QList<int> itemCounts = QList<int>() << 100 << 1000;
    QList<int> keySizes = QList<int>() << 100 << 512;
    QList<int> dataSizes = QList<int>() << 100 << 1000 << 2000 << 5000;
    setTestData(itemCounts, keySizes, dataSizes, false, false, true);
}

void TestHBtree::cursorWhileDelete()
{
    QFETCH(int, numItems);
    QFETCH(int, keySize);
    QFETCH(int, valueSize);
    QFETCH(bool, usePrevious);

    // Insert data
    QMap<QByteArray, QByteArray> keyValues;
    for (int i = 0; i < numItems; ++i) {
        QByteArray key = QString::number(i).toLatin1();
        if (key.size() < keySize)
            key += QByteArray(keySize - key.size(), '-');
        QByteArray value(valueSize, 'a' + (i % ('z' - 'a')));
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(key, value));
        keyValues.insert(key, value);
        QVERIFY(transaction->commit(i));
    }

    // Delete all
    HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    HBtreeCursor cursor1(txn);
    while (usePrevious ? cursor1.previous() : cursor1.next()) {
        QVERIFY(txn->del(cursor1.key()));
    }
    txn->commit(0);

    // Verify
    txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(txn);
    QMap<QByteArray, QByteArray>::iterator it = keyValues.begin();
    while (it != keyValues.end()) {
        QCOMPARE(txn->get(it.key()), QByteArray());
        ++it;
    }
    txn->abort();

    // Reinsert
    txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
    QVERIFY(txn);
    it = keyValues.begin();
    while (it != keyValues.end()) {
        QVERIFY(txn->put(it.key(), it.value()));
        ++it;
    }
    txn->commit(0);

    // Verify
    txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(txn);
    HBtreeCursor cursor2(txn);
    it = keyValues.begin();
    while (cursor2.next()) {
        QCOMPARE(it.key(), cursor2.key());
        QCOMPARE(it.value(), cursor2.value());
        ++it;
    }
    txn->abort();
}

void TestHBtree::getDataFromLastSync()
{
    db->setAutoSyncRate(0);

    int numCommits = 1000;
    for (int i = 0; i < numCommits / 2; ++i) {
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);
        QVERIFY(txn->put(QByteArray::number(i), QByteArray::number(i)));
        QVERIFY(txn->commit(i));
    }
    db->sync();

    for (int i = numCommits / 2; i < numCommits; ++i) {
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);
        QVERIFY(txn->put(QByteArray::number(i), QByteArray::number(i)));
        QVERIFY(txn->commit(i));
    }

    d->close(false);

    QVERIFY(db->open());
    QCOMPARE((int)db->tag(), numCommits / 2 - 1);

    for (int i = 0; i < numCommits / 2; ++i) {
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(txn);
        QCOMPARE(txn->get(QByteArray::number(i)), QByteArray::number(i));
        txn->abort();
    }

    for (int i = numCommits / 2; i < numCommits; ++i) {
        HBtreeTransaction *txn = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(txn);
        QVERIFY(txn->get(QByteArray::number(i)).isEmpty());
        txn->abort();
    }
}

void TestHBtree::deleteAlotNoSyncReopen_data()
{
    QList<int> itemCounts = QList<int>() << 100 << 1000;
    QList<int> dataSizes = QList<int>() << 100 << 1000 << 2000 << 5000;
    setTestData(itemCounts, QList<int>(), dataSizes);
}

void TestHBtree::deleteAlotNoSyncReopen()
{
    db->setAutoSyncRate(0);
    QFETCH(int, numItems);
    QFETCH(int, valueSize);

    // Put all in
    QMap<QByteArray, QByteArray> keyValues;
    for (int i = 0; i < numItems; ++i) {
        QByteArray key = QByteArray::number(i);
        QByteArray value(valueSize, 'a' + (i % ('z' - 'a')));
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(key, value));
        QVERIFY(transaction->commit(i));
        keyValues.insert(key, value);
    }

    // Delete first half
    for (int i = 0; i < numItems / 2; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->remove(QByteArray::number(i)));
        QVERIFY(transaction->commit(i));
    }

    QVERIFY(d->sync());

    // Delete second half
    for (int i = numItems / 2; i < numItems; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->remove(QByteArray::number(i)));
        QVERIFY(transaction->commit(i));
    }

    // Close without sync and reopen
    d->close(false);
    QVERIFY(db->open());

    // Verify not first half and yes second half
    HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
    QVERIFY(transaction);
    for (int i = 0; i < numItems / 2; ++i) {
        QCOMPARE(transaction->get(QByteArray::number(i)), QByteArray());
    }
    for (int i = numItems / 2; i < numItems; ++i) {
        QCOMPARE(transaction->get(QByteArray::number(i)), keyValues[QByteArray::number(i)]);
    }
    transaction->abort();

    // Put in first half
    for (int i = 0; i < numItems / 2; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(QByteArray::number(i), keyValues[QByteArray::number(i)]));
        QVERIFY(transaction->commit(i));
    }

    // Verify all
    transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
    for (int j = 0; j < numItems; ++j) {
        QCOMPARE(transaction->get(QByteArray::number(j)), keyValues[QByteArray::number(j)]);
    }
    transaction->abort();
}

void TestHBtree::customBlockSize()
{
    db->close();
    QFile::remove(dbname);
    d->spec_.pageSize = 4096 * 2;
    QVERIFY(db->open());
    HBtreeTransaction *txn = db->beginWrite();
    QVERIFY(txn);
    QVERIFY(txn->put(QByteArray("foo"), QByteArray("bar")));
    QVERIFY(txn->commit(0));
    db->close();
    QVERIFY(db->open());
    QCOMPARE(d->spec_.pageSize, (quint16)(4096 * 2));
    txn = db->beginRead();
    QVERIFY(txn);
    QCOMPARE(txn->get(QByteArray("foo")), QByteArray("bar"));
    txn->abort();
}

void TestHBtree::clearData()
{
    int numItems = 100;

    for (int i = 0; i < numItems; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadWrite);
        QVERIFY(transaction);
        QVERIFY(transaction->put(QByteArray::number(i), QByteArray::number(i)));
        QVERIFY(transaction->commit(i));
    }

    for (int i = 0; i < numItems; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(transaction);
        QCOMPARE(transaction->get(QByteArray::number(i)), QByteArray::number(i));
        transaction->abort();
    }

    QVERIFY(db->clearData());

    for (int i = 0; i < numItems; ++i) {
        HBtreeTransaction *transaction = db->beginTransaction(HBtreeTransaction::ReadOnly);
        QVERIFY(transaction);
        QCOMPARE(transaction->get(QByteArray::number(i)), QByteArray());
        transaction->abort();
    }
}

QTEST_MAIN(TestHBtree)
#include "main.moc"
